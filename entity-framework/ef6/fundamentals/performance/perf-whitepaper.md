---
title: Überlegungen zur Leistung für EF4, EF5 und EF6
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
ms.openlocfilehash: fb184fe8720b552a2050607bb17648f0413c31d1
ms.sourcegitcommit: c568d33214fc25c76e02c8529a29da7a356b37b4
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/30/2018
ms.locfileid: "47459590"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a><span data-ttu-id="6cfbd-102">Überlegungen zur Leistung für Entity Framework 4, 5 und 6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-102">Performance considerations for EF 4, 5, and 6</span></span>
<span data-ttu-id="6cfbd-103">Von David Obando, Eric Dettinger usw.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-103">By David Obando, Eric Dettinger and others</span></span>

<span data-ttu-id="6cfbd-104">Veröffentlichung: April 2012</span><span class="sxs-lookup"><span data-stu-id="6cfbd-104">Published: April 2012</span></span>

<span data-ttu-id="6cfbd-105">Letzte Aktualisierung: Mai 2014</span><span class="sxs-lookup"><span data-stu-id="6cfbd-105">Last updated: May 2014</span></span>

------------------------------------------------------------------------

## <a name="1-introduction"></a><span data-ttu-id="6cfbd-106">1. Einführung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-106">1. Introduction</span></span>

<span data-ttu-id="6cfbd-107">Object-Relational Mapping-Frameworks sind eine einfache Möglichkeit, eine Abstraktion für den Datenzugriff in einer objektorientierten Anwendung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-107">Object-Relational Mapping frameworks are a convenient way to provide an abstraction for data access in an object-oriented application.</span></span> <span data-ttu-id="6cfbd-108">Für .NET-Anwendungen empfohlen Microsofts O/RM Entity Framework ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-108">For .NET applications, Microsoft's recommended O/RM is Entity Framework.</span></span> <span data-ttu-id="6cfbd-109">Mit jeder Abstraktion kann die Leistung jedoch ist ein Problem auf.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-109">With any abstraction though, performance can become a concern.</span></span>

<span data-ttu-id="6cfbd-110">In diesem Whitepaper wurde geschrieben, Überlegungen zur Leistung angezeigt werden, bei der Entwicklung von Anwendungen mithilfe von Entity Framework, um einen Überblick über die internen Algorithmen des Entity Framework Entwicklern, die Leistung beeinträchtigen können und Tipps zur Untersuchung angeben und Verbessern der Leistung ihrer Anwendungen, die Entity Framework verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-110">This whitepaper was written to show the performance considerations when developing applications using Entity Framework, to give developers an idea of the Entity Framework internal algorithms that can affect performance, and to provide tips for investigation and improving performance in their applications that use Entity Framework.</span></span> <span data-ttu-id="6cfbd-111">Es stehen eine Reihe von guten Themen auf die Leistung bereits im Web, und außerdem haben wir versucht, diese Ressourcen auf, wenn möglich.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-111">There are a number of good topics on performance already available on the web, and we've also tried pointing to these resources where possible.</span></span>

<span data-ttu-id="6cfbd-112">Leistung ist ein kompliziertes Thema.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-112">Performance is a tricky topic.</span></span> <span data-ttu-id="6cfbd-113">Dieses Whitepaper dient als Ressource dazu, dass Sie die Leistung im Zusammenhang Entscheidungen für Ihre Anwendungen, die Entity Framework verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-113">This whitepaper is intended as a resource to help you make performance related decisions for your applications that use Entity Framework.</span></span> <span data-ttu-id="6cfbd-114">Wir haben einige Testmetriken, um die Leistungsvorteile enthalten, aber diese Metriken sind nicht als absolute Indikatoren, die die Leistung, die Sie in Ihrer Anwendung angezeigt werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-114">We have included some test metrics to demonstrate performance, but these metrics aren't intended as absolute indicators of the performance you will see in your application.</span></span>

<span data-ttu-id="6cfbd-115">Aus praktischen Gründen wird in diesem Dokument davon ausgegangen, Entity Framework 4 ist unter .NET 4.0 und Entity Framework 5 und 6 unter .NET 4.5 ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-115">For practical purposes, this document assumes Entity Framework 4 is run under .NET 4.0 and Entity Framework 5 and 6 are run under .NET 4.5.</span></span> <span data-ttu-id="6cfbd-116">Viele der leistungsverbesserungen für Entity Framework 5 befinden sich innerhalb der Kernkomponenten, die mit .NET 4.5 enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-116">Many of the performance improvements made for Entity Framework 5 reside within the core components that ship with .NET 4.5.</span></span>

<span data-ttu-id="6cfbd-117">Entitätsframework 6 ist ein Out-of-Band-Version und nicht von den Entity Framework-Komponenten, die mit .NET ausgeliefert abhängig.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-117">Entity Framework 6 is an out of band release and does not depend on the Entity Framework components that ship with .NET.</span></span> <span data-ttu-id="6cfbd-118">Entitätsframework 6 funktionieren auf .NET 4.0 und .NET 4.5, und eine großen Leistungssteigerung für diejenigen, die noch nicht von .NET 4.0 aktualisiert wurden, aber möchten die neuesten Entity Framework-Komponenten in ihrer Anwendung bieten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-118">Entity Framework 6 work on both .NET 4.0 and .NET 4.5, and can offer a big performance benefit to those who haven’t upgraded from .NET 4.0 but want the latest Entity Framework bits in their application.</span></span> <span data-ttu-id="6cfbd-119">In diesem Dokument Entity Framework 6 erwähnt, verweist auf die neueste Version, die zum Zeitpunkt der Erstellung dieses Dokuments: Version 6.1.0.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-119">When this document mentions Entity Framework 6, it refers to the latest version available at the time of this writing: version 6.1.0.</span></span>

## <a name="2-cold-vs-warm-query-execution"></a><span data-ttu-id="6cfbd-120">2. Kalte im Vergleich zu Warme Abfrageausführung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-120">2. Cold vs. Warm Query Execution</span></span>

<span data-ttu-id="6cfbd-121">Beim allerersten vorgenommenen jede Abfrage für ein bestimmtes Modell, führt das Entity Framework viel Arbeit im Hintergrund geladen und überprüft das Modell.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-121">The very first time any query is made against a given model, the Entity Framework does a lot of work behind the scenes to load and validate the model.</span></span> <span data-ttu-id="6cfbd-122">Wir bezeichnen häufig auf die erste Abfrage als Abfrage "kalt".</span><span class="sxs-lookup"><span data-stu-id="6cfbd-122">We frequently refer to this first query as a "cold" query.</span></span>  <span data-ttu-id="6cfbd-123">Weitere Abfragen für ein bereits geladenen Modell werden als "warmen" Abfragen bezeichnet, und Sie sind wesentlich schneller.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-123">Further queries against an already loaded model are known as "warm" queries, and are much faster.</span></span>

<span data-ttu-id="6cfbd-124">Lassen Sie uns einen allgemeinen Überblick darüber, wo Zeit verbracht wird, beim Ausführen einer Abfrage mithilfe von Entity Framework, und erfahren Sie, wo die Dinge in Entity Framework 6 verbessert wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-124">Let’s take a high-level view of where time is spent when executing a query using Entity Framework, and see where things are improving in Entity Framework 6.</span></span>

<span data-ttu-id="6cfbd-125">**Erste Ausführung der Abfrage – kalte Abfrage**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-125">**First Query Execution – cold query**</span></span>

| <span data-ttu-id="6cfbd-126">Die Benutzer schreibt Code</span><span class="sxs-lookup"><span data-stu-id="6cfbd-126">Code User Writes</span></span>                                                                                     | <span data-ttu-id="6cfbd-127">Aktion</span><span class="sxs-lookup"><span data-stu-id="6cfbd-127">Action</span></span>                    | <span data-ttu-id="6cfbd-128">EF4 Auswirkungen auf die Leistung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-128">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="6cfbd-129">EF5 Auswirkungen auf die Leistung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-129">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="6cfbd-130">EF6 Auswirkungen auf die Leistung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-130">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="6cfbd-131">Beim Erstellen des Serverkontexts</span><span class="sxs-lookup"><span data-stu-id="6cfbd-131">Context creation</span></span>          | <span data-ttu-id="6cfbd-132">Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-132">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="6cfbd-133">Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-133">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="6cfbd-134">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-134">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="6cfbd-135">Ausdruck abfragenerstellung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-135">Query expression creation</span></span> | <span data-ttu-id="6cfbd-136">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-136">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="6cfbd-137">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-137">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="6cfbd-138">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-138">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="6cfbd-139">LINQ-Abfragen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-139">LINQ query execution</span></span>      | <span data-ttu-id="6cfbd-140">-Metadaten geladen: hohe aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-140">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="6cfbd-141">– Anzeigen von Generation: potenziell sehr hohe aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-141">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="6cfbd-142">-Parameter Evaluierung: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-142">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="6cfbd-143">-Abfragen Übersetzung: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-143">- Query translation: Medium</span></span> <br/> <span data-ttu-id="6cfbd-144">-Materializer Generierung: mittlere aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-144">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="6cfbd-145">-Database abfrageausführung: möglicherweise hohen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-145">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="6cfbd-146">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="6cfbd-146">+ Connection.Open</span></span> <br/> <span data-ttu-id="6cfbd-147">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="6cfbd-147">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="6cfbd-148">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="6cfbd-148">+ DataReader.Read</span></span> <br/> <span data-ttu-id="6cfbd-149">-Objekt Materialisierung: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-149">Object materialization: Medium</span></span> <br/> <span data-ttu-id="6cfbd-150">-Identity-Suche: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-150">- Identity lookup: Medium</span></span> | <span data-ttu-id="6cfbd-151">-Metadaten geladen: hohe aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-151">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="6cfbd-152">– Anzeigen von Generation: potenziell sehr hohe aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-152">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="6cfbd-153">-Parameter Evaluierung: Low</span><span class="sxs-lookup"><span data-stu-id="6cfbd-153">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="6cfbd-154">-Abfragen Übersetzung: mittlere aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-154">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="6cfbd-155">-Materializer Generierung: mittlere aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-155">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="6cfbd-156">-Database abfrageausführung: möglicherweise hohen (Abfragen in einigen Situationen besser)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-156">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="6cfbd-157">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="6cfbd-157">+ Connection.Open</span></span> <br/> <span data-ttu-id="6cfbd-158">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="6cfbd-158">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="6cfbd-159">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="6cfbd-159">+ DataReader.Read</span></span> <br/> <span data-ttu-id="6cfbd-160">-Objekt Materialisierung: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-160">Object materialization: Medium</span></span> <br/> <span data-ttu-id="6cfbd-161">-Identity-Suche: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-161">- Identity lookup: Medium</span></span> | <span data-ttu-id="6cfbd-162">-Metadaten geladen: hohe aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-162">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="6cfbd-163">– Anzeigen von Generation: mittlere aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-163">- View generation: Medium but cached</span></span> <br/> <span data-ttu-id="6cfbd-164">-Parameter Evaluierung: Low</span><span class="sxs-lookup"><span data-stu-id="6cfbd-164">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="6cfbd-165">-Abfragen Übersetzung: mittlere aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-165">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="6cfbd-166">-Materializer Generierung: mittlere aber zwischengespeicherten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-166">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="6cfbd-167">-Database abfrageausführung: möglicherweise hohen (Abfragen in einigen Situationen besser)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-167">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="6cfbd-168">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="6cfbd-168">+ Connection.Open</span></span> <br/> <span data-ttu-id="6cfbd-169">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="6cfbd-169">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="6cfbd-170">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="6cfbd-170">+ DataReader.Read</span></span> <br/> <span data-ttu-id="6cfbd-171">-Objekt Materialisierung: Mittel (schneller als EF5)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-171">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="6cfbd-172">-Identity-Suche: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-172">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="6cfbd-173">Connection.Close durchführen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-173">Connection.Close</span></span>          | <span data-ttu-id="6cfbd-174">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-174">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="6cfbd-175">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-175">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="6cfbd-176">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-176">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


<span data-ttu-id="6cfbd-177">**Zweiten Abfrageausführung – betriebsbereiten Abfrage**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-177">**Second Query Execution – warm query**</span></span>

| <span data-ttu-id="6cfbd-178">Die Benutzer schreibt Code</span><span class="sxs-lookup"><span data-stu-id="6cfbd-178">Code User Writes</span></span>                                                                                     | <span data-ttu-id="6cfbd-179">Aktion</span><span class="sxs-lookup"><span data-stu-id="6cfbd-179">Action</span></span>                    | <span data-ttu-id="6cfbd-180">EF4 Auswirkungen auf die Leistung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-180">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="6cfbd-181">EF5 Auswirkungen auf die Leistung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-181">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="6cfbd-182">EF6 Auswirkungen auf die Leistung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-182">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="6cfbd-183">Beim Erstellen des Serverkontexts</span><span class="sxs-lookup"><span data-stu-id="6cfbd-183">Context creation</span></span>          | <span data-ttu-id="6cfbd-184">Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-184">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="6cfbd-185">Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-185">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="6cfbd-186">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-186">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="6cfbd-187">Ausdruck abfragenerstellung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-187">Query expression creation</span></span> | <span data-ttu-id="6cfbd-188">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-188">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="6cfbd-189">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-189">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="6cfbd-190">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-190">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="6cfbd-191">LINQ-Abfragen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-191">LINQ query execution</span></span>      | <span data-ttu-id="6cfbd-192">-Metadaten ~~laden~~ Suche: ~~aber zwischengespeicherten hohe~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-192">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-193">– Anzeigen von ~~Generation~~ Suche: ~~potenziell sehr hohe aber zwischengespeicherten~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-193">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-194">-Parameter Evaluierung: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-194">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="6cfbd-195">-Abfragen von ~~Übersetzung~~ Suche: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-195">- Query ~~translation~~ lookup: Medium</span></span> <br/> <span data-ttu-id="6cfbd-196">-Materializer ~~Generation~~ Suche: ~~Mittel, aber zwischengespeicherten~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-196">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-197">-Database abfrageausführung: möglicherweise hohen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-197">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="6cfbd-198">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="6cfbd-198">+ Connection.Open</span></span> <br/> <span data-ttu-id="6cfbd-199">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="6cfbd-199">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="6cfbd-200">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="6cfbd-200">+ DataReader.Read</span></span> <br/> <span data-ttu-id="6cfbd-201">-Objekt Materialisierung: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-201">Object materialization: Medium</span></span> <br/> <span data-ttu-id="6cfbd-202">-Identity-Suche: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-202">- Identity lookup: Medium</span></span> | <span data-ttu-id="6cfbd-203">-Metadaten ~~laden~~ Suche: ~~aber zwischengespeicherten hohe~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-203">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-204">– Anzeigen von ~~Generation~~ Suche: ~~potenziell sehr hohe aber zwischengespeicherten~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-204">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-205">-Parameter Evaluierung: Low</span><span class="sxs-lookup"><span data-stu-id="6cfbd-205">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="6cfbd-206">-Abfragen ~~Übersetzung~~ Suche: ~~Mittel, aber zwischengespeicherten~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-206">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-207">-Materializer ~~Generation~~ Suche: ~~Mittel, aber zwischengespeicherten~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-207">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-208">-Database abfrageausführung: möglicherweise hohen (Abfragen in einigen Situationen besser)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-208">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="6cfbd-209">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="6cfbd-209">+ Connection.Open</span></span> <br/> <span data-ttu-id="6cfbd-210">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="6cfbd-210">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="6cfbd-211">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="6cfbd-211">+ DataReader.Read</span></span> <br/> <span data-ttu-id="6cfbd-212">-Objekt Materialisierung: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-212">Object materialization: Medium</span></span> <br/> <span data-ttu-id="6cfbd-213">-Identity-Suche: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-213">- Identity lookup: Medium</span></span> | <span data-ttu-id="6cfbd-214">-Metadaten ~~laden~~ Suche: ~~aber zwischengespeicherten hohe~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-214">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-215">– Anzeigen von ~~Generation~~ Suche: ~~Mittel, aber zwischengespeicherten~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-215">- View ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-216">-Parameter Evaluierung: Low</span><span class="sxs-lookup"><span data-stu-id="6cfbd-216">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="6cfbd-217">-Abfragen ~~Übersetzung~~ Suche: ~~Mittel, aber zwischengespeicherten~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-217">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-218">-Materializer ~~Generation~~ Suche: ~~Mittel, aber zwischengespeicherten~~ niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-218">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="6cfbd-219">-Database abfrageausführung: möglicherweise hohen (Abfragen in einigen Situationen besser)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-219">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="6cfbd-220">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="6cfbd-220">+ Connection.Open</span></span> <br/> <span data-ttu-id="6cfbd-221">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="6cfbd-221">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="6cfbd-222">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="6cfbd-222">+ DataReader.Read</span></span> <br/> <span data-ttu-id="6cfbd-223">-Objekt Materialisierung: Mittel (schneller als EF5)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-223">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="6cfbd-224">-Identity-Suche: Mittel</span><span class="sxs-lookup"><span data-stu-id="6cfbd-224">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="6cfbd-225">Connection.Close durchführen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-225">Connection.Close</span></span>          | <span data-ttu-id="6cfbd-226">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-226">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="6cfbd-227">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-227">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="6cfbd-228">Niedrig</span><span class="sxs-lookup"><span data-stu-id="6cfbd-228">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


<span data-ttu-id="6cfbd-229">Es gibt mehrere Möglichkeiten zur Reduzierung der Leistungskosten von kalte und warme Abfragen, und wir werden sehen Sie sich diese im folgenden Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-229">There are several ways to reduce the performance cost of both cold and warm queries, and we'll take a look at these in the following section.</span></span> <span data-ttu-id="6cfbd-230">Genauer gesagt betrachten wir die kostenreduzierung von Modell laden in kalte Abfragen mit vorab generierten Sichten, mit dem Leistung-Probleme, die während des Generieren von Sichten zu verringern.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-230">Specifically, we'll look at reducing the cost of model loading in cold queries by using pre-generated views, which should help alleviate performance pains experienced during view generation.</span></span> <span data-ttu-id="6cfbd-231">Bei betriebsbereiten Abfragen wird die Zwischenspeichern von Abfrageplänen, keine Abfragen zur änderungsnachverfolgung und andere abfrageausführungsoptionen behandelt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-231">For warm queries, we'll cover query plan caching, no tracking queries, and different query execution options.</span></span>

### <a name="21-what-is-view-generation"></a><span data-ttu-id="6cfbd-232">2.1 Was Generieren von Sichten ist?</span><span class="sxs-lookup"><span data-stu-id="6cfbd-232">2.1 What is View Generation?</span></span>

<span data-ttu-id="6cfbd-233">Um zu verstehen, welche Ansicht ist Generation, wir müssen zunächst verstehen, was "Zuordnen von Ansichten" sind.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-233">In order to understand what view generation is, we must first understand what “Mapping Views” are.</span></span> <span data-ttu-id="6cfbd-234">Zuordnung von Ansichten sind ausführbare Darstellungen der Transformationen in der Zuordnung für jede Entitätenmenge und der Zuordnung angegeben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-234">Mapping Views are executable representations of the transformations specified in the mapping for each entity set and association.</span></span> <span data-ttu-id="6cfbd-235">Diese Zuordnung Ansichten intern die Form des CQTs (kanonische Abfrage Strukturen) in Anspruch nehmen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-235">Internally, these mapping views take the shape of CQTs (canonical query trees).</span></span> <span data-ttu-id="6cfbd-236">Es gibt zwei Arten von Ansichten der Zuordnung an:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-236">There are two types of mapping views:</span></span>

-   <span data-ttu-id="6cfbd-237">Abfrageansichten: Diese stellen die Transformation, die notwendig, wechseln aus dem Datenbankschema dem konzeptionellen Modell dar.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-237">Query views: these represent the transformation necessary to go from the database schema to the conceptual model.</span></span>
-   <span data-ttu-id="6cfbd-238">Sichten zu aktualisieren: Diese repräsentieren die Transformation erforderlich, um das Datenbankschema aus dem konzeptionellen Modell zu wechseln.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-238">Update views: these represent the transformation necessary to go from the conceptual model to the database schema.</span></span>

<span data-ttu-id="6cfbd-239">Bedenken Sie, die das konzeptionelle Modell aus dem Datenbankschema auf verschiedene Weise unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-239">Keep in mind that the conceptual model might differ from the database schema in various ways.</span></span> <span data-ttu-id="6cfbd-240">Beispielsweise kann eine einzelne Tabelle verwendet werden, zum Speichern der Daten für zwei verschiedene Entitätstypen verwendet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-240">For example, one single table might be used to store the data for two different entity types.</span></span> <span data-ttu-id="6cfbd-241">Vererbung und nicht trivialen Zuordnungen spielen eine Rolle, die Komplexität der Zuordnung Ansichten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-241">Inheritance and non-trivial mappings play a role in the complexity of the mapping views.</span></span>

<span data-ttu-id="6cfbd-242">Der Prozess der Datenverarbeitung diese Sichten auf Grundlage der Spezifikation der Zuordnung ist, Generieren von Sichten nennen wir.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-242">The process of computing these views based on the specification of the mapping is what we call view generation.</span></span> <span data-ttu-id="6cfbd-243">Generieren von Sichten kann entweder dynamisch stattfinden, wenn ein Modell geladen wird, oder zur Buildzeit mithilfe von "vorab generierten Sichten"; Letztere werden serialisiert, in Form von Entity SQL-Anweisungen für eine C-\# oder VB-Datei.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-243">View generation can either take place dynamically when a model is loaded, or at build time, by using "pre-generated views"; the latter are serialized in the form of Entity SQL statements to a C\# or VB file.</span></span>

<span data-ttu-id="6cfbd-244">Wenn Ansichten generiert werden, werden diese ebenfalls überprüft.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-244">When views are generated, they are also validated.</span></span> <span data-ttu-id="6cfbd-245">Vom Standpunkt der Leistung ist die große Mehrheit der Kosten der Generieren von Sichten tatsächlich für die Überprüfung der Ansichten wird sichergestellt, dass die Verbindungen zwischen den Entitäten sinnvoll sind und die korrekte Kardinalität für alle unterstützten Vorgänge haben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-245">From a performance standpoint, the vast majority of the cost of view generation is actually the validation of the views which ensures that the connections between the entities make sense and have the correct cardinality for all the supported operations.</span></span>

<span data-ttu-id="6cfbd-246">Wenn eine Abfrage über eine Entitätenmenge ausgeführt wird, wird die Abfrage mit entsprechenden Ansicht "Abfrage" kombiniert, und das Ergebnis dieser Zusammensetzung wird ausgeführt, durch den Plan-Compiler die Darstellung der Abfrage zu erstellen, die der Sicherungsspeicher verstehen kann.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-246">When a query over an entity set is executed, the query is combined with the corresponding query view, and the result of this composition is run through the plan compiler to create the representation of the query that the backing store can understand.</span></span> <span data-ttu-id="6cfbd-247">Für SQL Server werden das endgültige Ergebnis dieser Kompilierung einer T-SQL SELECT-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-247">For SQL Server, the final result of this compilation will be a T-SQL SELECT statement.</span></span> <span data-ttu-id="6cfbd-248">Das erste Mal, das ein Update über eine Entitätenmenge ausgeführt wird, das wird der Updateansicht über einen ähnlichen Prozess die Transformation in DML-Anweisungen für die Zieldatenbank ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-248">The first time an update over an entity set is performed, the update view is run through a similar process to transform it into DML statements for the target database.</span></span>

### <a name="22-factors-that-affect-view-generation-performance"></a><span data-ttu-id="6cfbd-249">2.2-Faktoren, die Leistungseinbußen führen Generieren von Sichten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-249">2.2 Factors that affect View Generation performance</span></span>

<span data-ttu-id="6cfbd-250">Die Leistung der Ansicht Generation Schritt hängt nicht nur auf die Größe des Modells, sondern auch dazu, wie verbundene des Modells ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-250">The performance of view generation step not only depends on the size of your model but also on how interconnected the model is.</span></span> <span data-ttu-id="6cfbd-251">Wenn zwei Entitäten mit einer Vererbungskette oder eine Zuordnung verbunden sind, werden sie als verbunden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-251">If two Entities are connected via an inheritance chain or an Association, they are said to be connected.</span></span> <span data-ttu-id="6cfbd-252">Auf ähnliche Weise werden zwei Tabellen über einen Fremdschlüssel verbunden sind, sie verbunden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-252">Similarly if two tables are connected via a foreign key, they are connected.</span></span> <span data-ttu-id="6cfbd-253">Erhöhen Sie die Anzahl von verbundenen Entitäten und Tabellen in Ihren Schemas, Kosten für die Erstellung erhöht.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-253">As the number of connected Entities and tables in your schemas increase, the view generation cost increases.</span></span>

<span data-ttu-id="6cfbd-254">Der Algorithmus, den zum Generieren und überprüfen die Ansichten verwenden wir ist im ungünstigsten Fall exponentiellen, obwohl wir einige Optimierungen verwenden, um dies zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-254">The algorithm that we use to generate and validate views is exponential in the worst case, though we do use some optimizations to improve this.</span></span> <span data-ttu-id="6cfbd-255">Die wichtigsten Faktoren, die die Leistung negativ beeinflussen scheinen sind:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-255">The biggest factors that seem to negatively affect performance are:</span></span>

-   <span data-ttu-id="6cfbd-256">Modell Größe auf die Anzahl der Entitäten und die Menge der Zuordnungen zwischen diesen Entitäten verweisen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-256">Model size, referring to the number of entities and the amount of associations between these entities.</span></span>
-   <span data-ttu-id="6cfbd-257">Modell die Komplexität, insbesondere eine große Anzahl von Typen mit Vererbung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-257">Model complexity, specifically inheritance involving a large number of types.</span></span>
-   <span data-ttu-id="6cfbd-258">Anstelle von unabhängigen Zuordnungen Foreign Key-Zuordnungen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-258">Using Independent Associations, instead of Foreign Key Associations.</span></span>

<span data-ttu-id="6cfbd-259">Für kleine, einfache Modelle möglicherweise die Kosten klein genug ist, zu nicht vorab generierte Sichten verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-259">For small, simple models the cost may be small enough to not bother using pre-generated views.</span></span> <span data-ttu-id="6cfbd-260">Modellgröße und Komplexität zu erhöhen, gibt es mehrere Optionen zur Verfügung, die Kosten der Generieren von Sichten und Validierung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-260">As model size and complexity increase, there are several options available to reduce the cost of view generation and validation.</span></span>

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a><span data-ttu-id="6cfbd-261">2.3 Pre-Generated Ansichten verwenden, Modell zu verringern, die Ladezeit</span><span class="sxs-lookup"><span data-stu-id="6cfbd-261">2.3 Using Pre-Generated Views to decrease model load time</span></span>

<span data-ttu-id="6cfbd-262">Ausführliche Informationen zur Verwendung von vorab generierten Sichten zu Entity Framework 6 finden Sie unter [Pre-Generated Zuordnen von Ansichten](~/ef6/fundamentals/performance/pre-generated-views.md)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-262">For detailed information on how to use pre-generated views on Entity Framework 6 visit [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md)</span></span>

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a><span data-ttu-id="6cfbd-263">2.3.1 vorab generierten Sichten, die mithilfe von Entity Framework Power Tools-Community-Edition</span><span class="sxs-lookup"><span data-stu-id="6cfbd-263">2.3.1 Pre-Generated views using the Entity Framework Power Tools Community Edition</span></span>

<span data-ttu-id="6cfbd-264">Können Sie die [Community-Edition von Entity Framework 6 Power Tools](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) auf Ansichten der EDMX-Datei und Code First-Modelle zu generieren, indem Sie mit der rechten Maustaste der Modell-Klassendatei, und mithilfe des Entity Framework-Menüs "Ansichten generieren" auswählen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-264">You can use the [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) to generate views of EDMX and Code First models by right-clicking the model class file and using the Entity Framework menu to select “Generate Views”.</span></span> <span data-ttu-id="6cfbd-265">Die Entity Framework Power Tools-Community-Edition können nur für Kontexte "DbContext" abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-265">The Entity Framework Power Tools Community Edition work only on DbContext-derived contexts.</span></span>

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a><span data-ttu-id="6cfbd-266">2.3.2, wie Sie mit vorab generierten Sichten mit einem Modell EDMGen erstellt</span><span class="sxs-lookup"><span data-stu-id="6cfbd-266">2.3.2 How to use Pre-generated views with a model created by EDMGen</span></span>

<span data-ttu-id="6cfbd-267">EDMGen ist ein Hilfsprogramm, das im Lieferumfang von .NET und funktioniert mit Entity Framework 4 und 5, jedoch nicht mit Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-267">EDMGen is a utility that ships with .NET and works with Entity Framework 4 and 5, but not with Entity Framework 6.</span></span> <span data-ttu-id="6cfbd-268">EDMGen können Sie eine Modelldatei, der Objektebene und die Ansichten über die Befehlszeile zu generieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-268">EDMGen allows you to generate a model file, the object layer and the views from the command line.</span></span> <span data-ttu-id="6cfbd-269">Eine der Ausgaben werden eine Ansichten-Datei in der Sprache Ihrer Wahl, VB oder C#\#.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-269">One of the outputs will be a Views file in your language of choice, VB or C\#.</span></span> <span data-ttu-id="6cfbd-270">Dies ist eine Codedatei mit Entity SQL-Codeausschnitte für jede Entitätenmenge.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-270">This is a code file containing Entity SQL snippets for each entity set.</span></span> <span data-ttu-id="6cfbd-271">Um Sichten zu aktivieren, fügen Sie einfach die Datei in Ihrem Projekt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-271">To enable pre-generated views, you simply include the file in your project.</span></span>

<span data-ttu-id="6cfbd-272">Wenn Sie die Schemadateien für das Modell manuell Änderungen vornehmen, müssen Sie die Ansichten-Datei erneut zu generieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-272">If you manually make edits to the schema files for the model, you will need to re-generate the views file.</span></span> <span data-ttu-id="6cfbd-273">Hierzu können Sie EDMGen mit Ausführen der **/mode:ViewGeneration** Flag.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-273">You can do this by running EDMGen with the **/mode:ViewGeneration** flag.</span></span>

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a><span data-ttu-id="6cfbd-274">2.3.3 Verwendung Pre-Generated Ansichten mit einer EDMX-Datei</span><span class="sxs-lookup"><span data-stu-id="6cfbd-274">2.3.3 How to use Pre-Generated Views with an EDMX file</span></span>

<span data-ttu-id="6cfbd-275">Sie können auch EDMGen verwenden, um Ansichten für eine EDMX-Datei zu generieren: im zuvor erwähnten MSDN-Thema wird beschrieben, wie eine Präbuildereignis - dazu hinzufügen, aber dies ist kompliziert und es gibt einige Fälle, in denen es nicht möglich ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-275">You can also use EDMGen to generate views for an EDMX file - the previously referenced MSDN topic describes how to add a pre-build event to do this - but this is complicated and there are some cases where it isn't possible.</span></span> <span data-ttu-id="6cfbd-276">Es ist im Allgemeinen leichter zu eine T4-Vorlage zu verwenden, um die Ansichten zu generieren, wenn Ihr Modell in einer Edmx-Datei ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-276">It's generally easier to use a T4 template to generate the views when your model is in an edmx file.</span></span>

<span data-ttu-id="6cfbd-277">ADO.NET-Teamblog hat einen Beitrag, der beschreibt, wie Sie mit einer T4-Vorlage für das Generieren von Sichten ( \<http://blogs.msdn.com/b/adonet/archive/2008/06/20/how-to-use-a-t4-template-for-view-generation.aspx>).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-277">The ADO.NET team blog has a post that describes how to use a T4 template for view generation ( \<http://blogs.msdn.com/b/adonet/archive/2008/06/20/how-to-use-a-t4-template-for-view-generation.aspx>).</span></span> <span data-ttu-id="6cfbd-278">Dieser Beitrag enthält eine Vorlage, die heruntergeladen und dem Projekt hinzugefügt werden kann.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-278">This post includes a template that can be downloaded and added to your project.</span></span> <span data-ttu-id="6cfbd-279">Die Vorlage wurde für die erste Version von Entity Framework geschrieben, sodass sie garantiert sind nicht mit den neuesten Versionen von Entity Framework arbeiten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-279">The template was written for the first version of Entity Framework, so they aren’t guaranteed to work with the latest versions of Entity Framework.</span></span> <span data-ttu-id="6cfbd-280">Allerdings können Sie einem aktuelleren Satz von Generation Ansichtsvorlagen für Entity Framework 4 und 5from der Visual Studio Gallery herunterladen:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-280">However, you can download a more up-to-date set of view generation templates for Entity Framework 4 and 5from the Visual Studio Gallery:</span></span>

-   <span data-ttu-id="6cfbd-281">VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span><span class="sxs-lookup"><span data-stu-id="6cfbd-281">VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span></span>
-   <span data-ttu-id="6cfbd-282">C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span><span class="sxs-lookup"><span data-stu-id="6cfbd-282">C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span></span>

<span data-ttu-id="6cfbd-283">Bei Verwendung von Entity Framework 6 erhalten Sie die Ansicht Generation T4-Vorlagen aus Visual Studio Gallery unter \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-283">If you’re using Entity Framework 6 you can get the view generation T4 templates from the Visual Studio Gallery at \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span></span>

### <a name="24-reducing-the-cost-of-view-generation"></a><span data-ttu-id="6cfbd-284">2.4 Senkung der Kosten der Generieren von Sichten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-284">2.4 Reducing the cost of view generation</span></span>

<span data-ttu-id="6cfbd-285">Verwenden von vorab generierten Sichten verschiebt die Kosten für das Generieren von Sichten aus Modell laden (Laufzeit) zur Entwurfszeit.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-285">Using pre-generated views moves the cost of view generation from model loading (run time) to design time.</span></span> <span data-ttu-id="6cfbd-286">Während dies verbessert die Leistung beim Start zur Laufzeit, dennoch treten die Probleme beim Generieren von Sichten während der Entwicklung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-286">While this improves startup performance at runtime, you will still experience the pain of view generation while you are developing.</span></span> <span data-ttu-id="6cfbd-287">Es gibt einige zusätzliche Tricks, die die Kosten für das Generieren von Sichten, sowohl zur Kompilierzeit und Laufzeit verringern können.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-287">There are several additional tricks that can help reduce the cost of view generation, both at compile time and run time.</span></span>

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a><span data-ttu-id="6cfbd-288">2.4.1 mithilfe anzeigen Generation von Kosten reduzieren von Foreign Key-Zuordnungen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-288">2.4.1 Using Foreign Key Associations to reduce view generation cost</span></span>

<span data-ttu-id="6cfbd-289">Wir haben gesehen, eine Reihe von Fällen, in denen wechseln von Zuordnungen in das Modell von unabhängigen Zuordnungen auf Zuordnungen von Foreign Key drastisch die Zeit im Generieren von Sichten verbessert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-289">We have seen a number of cases where switching the associations in the model from Independent Associations to Foreign Key Associations dramatically improved the time spent in view generation.</span></span>

<span data-ttu-id="6cfbd-290">Um diese Verbesserung zu demonstrieren, haben wir zwei Versionen des Modells Navision mithilfe von EDMGen generiert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-290">To demonstrate this improvement, we generated two versions of the Navision model by using EDMGen.</span></span> <span data-ttu-id="6cfbd-291">*Hinweis: Seeappendix Cfor eine Beschreibung des Modells Navision.*</span><span class="sxs-lookup"><span data-stu-id="6cfbd-291">*Note: seeappendix Cfor a description of the Navision model.*</span></span> <span data-ttu-id="6cfbd-292">Das Modell Navision ist für diese Übung, aufgrund dessen große Menge von Entitäten und Beziehungen zwischen ihnen interessant.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-292">The Navision model is interesting for this exercise due to its very large amount of entities and relationships between them.</span></span>

<span data-ttu-id="6cfbd-293">Eine Version dieses Modells sehr große mit Zuordnungen von Foreign-Schlüssel generiert wurde, und der andere mit unabhängigen Zuordnungen generiert wurde.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-293">One version of this very large model was generated with Foreign Keys Associations and the other was generated with Independent Associations.</span></span> <span data-ttu-id="6cfbd-294">Klicken Sie dann Timeout wir bei, wie lang es gedauert, um die Ansichten für jedes Modell zu generieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-294">We then timed how long it took to generate the views for each model.</span></span> <span data-ttu-id="6cfbd-295">Entität Framework5-Test verwendet die GenerateViews()-Methode aus der Klasse EntityViewGenerator, um den Ansichten zu generieren, während der Entity Framework 6-Test die GenerateViews()-Methode aus der Klasse StorageMappingItemCollection verwendet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-295">Entity Framework5 test used the GenerateViews() method from class EntityViewGenerator to generate the views, while the Entity Framework 6 test used the GenerateViews() method from class StorageMappingItemCollection.</span></span> <span data-ttu-id="6cfbd-296">Dies ist aufgrund von Code umstrukturieren, die in der Entity Framework 6-Codebasis aufgetreten sind.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-296">This due to code restructuring that occurred in the Entity Framework 6 codebase.</span></span>

<span data-ttu-id="6cfbd-297">Mithilfe von Entity Framework 5, dauerte Generieren von Sichten für das Modell mit Fremdschlüsseln 65 Minuten, in einer Lab-Computer.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-297">Using Entity Framework 5, view generation for the model with Foreign Keys took 65 minutes in a lab machine.</span></span> <span data-ttu-id="6cfbd-298">Es unbekannten wie lange erforderlich gewesen wäre, um die Ansichten für das Modell zu generieren, die unabhängige Zuordnungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-298">It's unknown how long it would have taken to generate the views for the model that used independent associations.</span></span> <span data-ttu-id="6cfbd-299">Wir bleiben den Test ausführen, die für mehr als einem Monat, bevor der Computer neu gestartet wurde, in unserer testumgebung monatlichen Updates zu installieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-299">We left the test running for over a month before the machine was rebooted in our lab to install monthly updates.</span></span>

<span data-ttu-id="6cfbd-300">Verwendung von Entity Framework 6, dauerte Generieren von Sichten für das Modell mit Fremdschlüsseln, 28 Sekunden, in dem gleichen Lab-Computer.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-300">Using Entity Framework 6, view generation for the model with Foreign Keys took 28 seconds in the same lab machine.</span></span> <span data-ttu-id="6cfbd-301">Generieren von Sichten für das Modell, das unabhängigen Zuordnungen verwendet hat 58 Sekunden gedauert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-301">View generation for the model that uses Independent Associations took 58 seconds.</span></span> <span data-ttu-id="6cfbd-302">Die Verbesserungen, die auf Entity Framework 6 auf seine Ansicht generierungscodes bedeuten, dass es sich bei vielen Projekten nicht vorab generierte Sichten, um schnellere Startzeiten zu erhalten benötigen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-302">The improvements done to Entity Framework 6 on its view generation code mean that many projects won’t need pre-generated views to obtain faster startup times.</span></span>

<span data-ttu-id="6cfbd-303">Es ist wichtig, die Anmerkung, die mit EDMGen oder die Entity Framework Power Tools vorgenerieren von Ansichten im Entity Framework 4 und 5 ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-303">It’s important to remark that pre-generating views in Entity Framework 4 and 5 can be done with EDMGen or the Entity Framework Power Tools.</span></span> <span data-ttu-id="6cfbd-304">Für Entity Framework 6-Ansicht Generation kann erfolgen über die Entity Framework Power Tools oder programmgesteuert, siehe [Pre-Generated Zuordnen von Ansichten](~/ef6/fundamentals/performance/pre-generated-views.md).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-304">For Entity Framework 6 view generation can be done via the Entity Framework Power Tools or programmatically as described in [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md).</span></span>

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a><span data-ttu-id="6cfbd-305">2.4.1.1, wie Sie mit Fremdschlüsseln anstelle von unabhängigen Zuordnungen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-305">2.4.1.1 How to use Foreign Keys instead of Independent Associations</span></span>

<span data-ttu-id="6cfbd-306">Wenn EDMGen oder der Entity Designer in Visual Studio verwenden, erhalten Sie ein Fremdschlüssel in der Standardeinstellung, und es dauert nur einen einzigen Kontrollkästchen oder über die Befehlszeile Flag zum Wechseln zwischen Fremdschlüssel und IAs.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-306">When using EDMGen or the Entity Designer in Visual Studio, you get FKs by default, and it only takes a single checkbox or command line flag to switch between FKs and IAs.</span></span>

<span data-ttu-id="6cfbd-307">Wenn Sie ein großes Code First-Modell verfügen, müssen die unabhängigen Zuordnungen mit, dass die gleiche Wirkung auf das Generieren von Sichten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-307">If you have a large Code First model, using Independent Associations will have the same effect on view generation.</span></span> <span data-ttu-id="6cfbd-308">Sie diese Auswirkungen zu vermeiden, einschließlich der Foreign Key-Eigenschaften für die Klassen für die abhängige Objekte, obwohl manche Entwickler diese Option, um ihr Objektmodell zu stören, werden berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-308">You can avoid this impact by including Foreign Key properties on the classes for your dependent objects, though some developers will consider this to be polluting their object model.</span></span> <span data-ttu-id="6cfbd-309">Sie finden weitere Informationen zu diesem Thema im \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-309">You can find more information on this subject in \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span></span>

| <span data-ttu-id="6cfbd-310">Bei Verwendung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-310">When using</span></span>      | <span data-ttu-id="6cfbd-311">Vorgehensweise</span><span class="sxs-lookup"><span data-stu-id="6cfbd-311">Do this</span></span>                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="6cfbd-312">Entity Designer</span><span class="sxs-lookup"><span data-stu-id="6cfbd-312">Entity Designer</span></span> | <span data-ttu-id="6cfbd-313">Nach dem Hinzufügen einer Zuordnung zwischen zwei Entitäten, sicher, dass eine referenzielle Einschränkung besitzt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-313">After adding an association between two entities, make sure you have a referential constraint.</span></span> <span data-ttu-id="6cfbd-314">Referenzielle Einschränkungen Teilen Entity Framework zum Fremdschlüssel anstatt unabhängige Zuordnungen verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-314">Referential constraints tell Entity Framework to use Foreign Keys instead of Independent Associations.</span></span> <span data-ttu-id="6cfbd-315">Weitere Informationen finden Sie unter \<http://blogs.msdn.com/b/efdesign/archive/2009/03/16/foreign-keys-in-the-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-315">For additional details visit \<http://blogs.msdn.com/b/efdesign/archive/2009/03/16/foreign-keys-in-the-entity-framework.aspx>.</span></span> |
| <span data-ttu-id="6cfbd-316">EDMGen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-316">EDMGen</span></span>          | <span data-ttu-id="6cfbd-317">Wenn EDMGen verwenden, um Ihre Dateien aus der Datenbank zu generieren, wird Ihre Fremdschlüssel berücksichtigt und das Modell daher hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-317">When using EDMGen to generate your files from the database, your Foreign Keys will be respected and added to the model as such.</span></span> <span data-ttu-id="6cfbd-318">Weitere Informationen zu den verschiedenen Optionen, die verfügbar gemacht werden, indem EDMGen finden Sie [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-318">For more information on the different options exposed by EDMGen visit [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span></span>                           |
| <span data-ttu-id="6cfbd-319">Code First</span><span class="sxs-lookup"><span data-stu-id="6cfbd-319">Code First</span></span>      | <span data-ttu-id="6cfbd-320">Finden Sie im Abschnitt "Beziehung Konvention" die [Code First-Konventionen](~/ef6/modeling/code-first/conventions/built-in.md) Thema enthält Informationen zum Fremdschlüsseleigenschaften für abhängige Objekte einschließen, wenn Sie Code First verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-320">See the "Relationship Convention" section of the [Code First Conventions](~/ef6/modeling/code-first/conventions/built-in.md) topic for information on how to include foreign key properties on dependent objects when using Code First.</span></span>                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a><span data-ttu-id="6cfbd-321">2.4.2 verschieben Ihr Modell in eine separate assembly</span><span class="sxs-lookup"><span data-stu-id="6cfbd-321">2.4.2 Moving your model to a separate assembly</span></span>

<span data-ttu-id="6cfbd-322">Wenn Ihr Modell direkt in Ihrer Anwendung Projekt enthalten ist, und Sie die Sichten, die über ein Ereignis vor dem Erstellen oder eine T4-Vorlage generieren, Generieren von Sichten und Überprüfung erfolgt wird, wenn das Projekt neu erstellt wird, selbst wenn das Modell geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-322">When your model is included directly in your application's project and you generate views through a pre-build event or a T4 template, view generation and validation will take place whenever the project is rebuilt, even if the model wasn't changed.</span></span> <span data-ttu-id="6cfbd-323">Wenn Sie das Modell in eine separate Assembly verschieben und verweisen sie aus dem Projekt Ihrer Anwendung hinzu, können Sie andere Änderungen für Ihre Anwendung vornehmen, ohne das Projekt mit dem Modell neu erstellen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-323">If you move the model to a separate assembly and reference it from your application's project, you can make other changes to your application without needing to rebuild the project containing the model.</span></span>

<span data-ttu-id="6cfbd-324">*Hinweis:* beim Verschieben von Modell aus, um separate Assemblys Denken Sie daran, die Verbindungszeichenfolgen für das Modell in der Anwendungskonfigurationsdatei des Clientprojekts zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-324">*Note:*  when moving your model to separate assemblies remember to copy the connection strings for the model into the application configuration file of the client project.</span></span>

#### <a name="243-disable-validation-of-an-edmx-based-model"></a><span data-ttu-id="6cfbd-325">2.4.3 Deaktivieren der Validierung des eine Edmx-basierten Modells</span><span class="sxs-lookup"><span data-stu-id="6cfbd-325">2.4.3 Disable validation of an edmx-based model</span></span>

<span data-ttu-id="6cfbd-326">EDMX-Modelle werden zum Zeitpunkt der Kompilierung überprüft, auch wenn das Modell unverändert ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-326">EDMX models are validated at compile time, even if the model is unchanged.</span></span> <span data-ttu-id="6cfbd-327">Wenn Ihr Modell bereits überprüft wurde, können Sie die Überprüfung zur Kompilierzeit unterdrücken, durch die Eigenschaft "Auf Build überprüfen" auf "false" festlegen, im Eigenschaftenfenster.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-327">If your model has already been validated, you can suppress validation at compile time by setting the "Validate on Build" property to false in the properties window.</span></span> <span data-ttu-id="6cfbd-328">Wenn Sie Ihre Zuordnung oder das Modell ändern, können Sie vorübergehend Überprüfung, um zu überprüfen, ob die Änderungen erneut aktivieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-328">When you change your mapping or model, you can temporarily re-enable validation to verify your changes.</span></span>

<span data-ttu-id="6cfbd-329">Beachten Sie, dass die wurden leistungsverbesserungen vorgenommen, die Entity Framework Designer für Entity Framework 6, und die Kosten für die "Überprüfen für Build" ist wesentlich geringer als in früheren Versionen des Designers.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-329">Note that performance improvements were made to the Entity Framework Designer for Entity Framework 6, and the cost of the “Validate on Build” is much lower than in previous versions of the designer.</span></span>

## <a name="3-caching-in-the-entity-framework"></a><span data-ttu-id="6cfbd-330">3-Zwischenspeicherung in Entitätsframework</span><span class="sxs-lookup"><span data-stu-id="6cfbd-330">3 Caching in the Entity Framework</span></span>

<span data-ttu-id="6cfbd-331">Entitätsframework gibt es die folgenden Formen Zwischenspeichern integrierte:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-331">Entity Framework has the following forms of caching built-in:</span></span>

1.  <span data-ttu-id="6cfbd-332">Objekt Zwischenspeichern – verfolgt das ObjectStateManager integriert eine ObjectContext-Instanz im Arbeitsspeicher, der die Objekte, die mit dieser Instanz abgerufen wurden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-332">Object caching – the ObjectStateManager built into an ObjectContext instance keeps track in memory of the objects that have been retrieved using that instance.</span></span> <span data-ttu-id="6cfbd-333">Dies ist auch bekannt als E1-Cache.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-333">This is also known as first-level cache.</span></span>
2.  <span data-ttu-id="6cfbd-334">Abfrage-Plan Caching - generierten Speicherbefehl wiederverwenden, wenn eine Abfrage mehr als einmal ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-334">Query Plan Caching - reusing the generated store command when a query is executed more than once.</span></span>
3.  <span data-ttu-id="6cfbd-335">Metadaten, die caching - die Metadaten für ein Modell für andere Verbindungen mit dem gleichen Modell freigegeben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-335">Metadata caching - sharing the metadata for a model across different connections to the same model.</span></span>

<span data-ttu-id="6cfbd-336">Neben der Caches, die EF standardmäßig eine besondere Art von ADO.NET-Datenanbieter, nämlich ein Wrapping-Anbieter auch verwendet werden kann, zum Erweitern von Entity Framework mit einem Cache für die aus der Datenbank abgerufenen Ergebnisse enthält auch bekannt als Zwischenspeicherung auf zweiter Ebene.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-336">Besides the caches that EF provides out of the box, a special kind of ADO.NET data provider known as a wrapping provider can also be used to extend Entity Framework with a cache for the results retrieved from the database, also known as second-level caching.</span></span>

### <a name="31-object-caching"></a><span data-ttu-id="6cfbd-337">3.1 Objekt Zwischenspeichern</span><span class="sxs-lookup"><span data-stu-id="6cfbd-337">3.1 Object Caching</span></span>

<span data-ttu-id="6cfbd-338">Standardmäßig beim Zurückgeben einer Entität in den Ergebnissen einer Abfrage, überprüft kurz bevor EF, materialisiert Sie ObjectContext, ob eine Entität mit dem gleichen Schlüssel bereits in der ObjectStateManager geladen wurde.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-338">By default when an entity is returned in the results of a query, just before EF materializes it, the ObjectContext will check if an entity with the same key has already been loaded into its ObjectStateManager.</span></span> <span data-ttu-id="6cfbd-339">Wenn eine Entität mit dem gleichen Schlüssel bereits vorhanden ist wird EF diese in den Ergebnissen der Abfrage enthalten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-339">If an entity with the same keys is already present EF will include it in the results of the query.</span></span> <span data-ttu-id="6cfbd-340">Obwohl EF die Abfrage für die Datenbank weiterhin ausstellt, kann ein Großteil der Kosten für die Materialisierung der Entitäts mehrmals dieses Verhalten umgangen werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-340">Although EF will still issue the query against the database, this behavior can bypass much of the cost of materializing the entity multiple times.</span></span>

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a><span data-ttu-id="6cfbd-341">3.1.1 Abrufen von Entitäten aus der Objektcache mit "DbContext" Suchen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-341">3.1.1 Getting entities from the object cache using DbContext Find</span></span>

<span data-ttu-id="6cfbd-342">Im Gegensatz zu einer regelmäßigen Abfrage wird die Find-Methode in "DbSet" (APIs, die zum ersten Mal in EF 4.1 enthalten) eine Suche im Arbeitsspeicher auszuführen, bevor Sie auch die Ausgabe der Abfrage für die Datenbank.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-342">Unlike a regular query, the Find method in DbSet (APIs included for the first time in EF 4.1) will perform a search in memory before even issuing the query against the database.</span></span> <span data-ttu-id="6cfbd-343">Es ist wichtig zu beachten, dass zwei verschiedene ObjectContext-Instanzen zwei verschiedene ObjectStateManager-Instanzen hat, was bedeutet, dass sie separate Objektcaches aufweisen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-343">It’s important to note that two different ObjectContext instances will have two different ObjectStateManager instances, meaning that they have separate object caches.</span></span>

<span data-ttu-id="6cfbd-344">Suchen wird mit dem Wert des Primärschlüssels finden Sie eine Entität, die vom Kontext nachverfolgt versucht.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-344">Find uses the primary key value to attempt to find an entity tracked by the context.</span></span> <span data-ttu-id="6cfbd-345">Ist die Entität nicht im Kontext eine Abfrage wird ausgeführt und werden in der Datenbank ausgewertet, und Null wird zurückgegeben, wenn die Entität nicht im Kontext oder in der Datenbank gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-345">If the entity is not in the context then a query will be executed and evaluated against the database, and null is returned if the entity is not found in the context or in the database.</span></span> <span data-ttu-id="6cfbd-346">Beachten Sie, dass suchen auch Entitäten zurückgibt, die dem Kontext hinzugefügt wurden, aber noch nicht mit der Datenbank gespeichert wurde.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-346">Note that Find also returns entities that have been added to the context but have not yet been saved to the database.</span></span>

<span data-ttu-id="6cfbd-347">Es gibt eine leistungsoptimierung mit der Suche verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-347">There is a performance consideration to be taken when using Find.</span></span> <span data-ttu-id="6cfbd-348">Aufrufe dieser Methode werden standardmäßig werden eine Überprüfung des Objektcaches ausgelöst, um die Änderungen zu erkennen, die Commit an die Datenbank immer noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-348">Invocations to this method by default will trigger a validation of the object cache in order to detect changes that are still pending commit to the database.</span></span> <span data-ttu-id="6cfbd-349">Dieser Prozess kann sehr teuer sein, wenn es gibt eine sehr große Anzahl von Objekten im Objektcache oder in einem LOB-Diagramm hinzugefügte Objektcache sein, aber sie kann auch deaktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-349">This process can be very expensive if there are a very large number of objects in the object cache or in a large object graph being added to the object cache, but it can also be disabled.</span></span> <span data-ttu-id="6cfbd-350">In bestimmten Fällen können Sie wahrnehmen über eine Größenordnung des Unterschieds bei Aufrufen der Methode, wenn das Deaktivieren der automatischen Erkennung finden Änderungen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-350">In certain cases, you may perceive over an order of magnitude of difference in calling the Find method when you disable auto detect changes.</span></span> <span data-ttu-id="6cfbd-351">Ein zweites bedeutend wird noch angesehen, wenn das Objekt tatsächlich in den Cache ist, wenn das Objekt wurde aus der Datenbank abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-351">Yet a second order of magnitude is perceived when the object actually is in the cache versus when the object has to be retrieved from the database.</span></span> <span data-ttu-id="6cfbd-352">Hier ist ein Beispieldiagramm mit Messungen, die mit einigen unserer Microbenchmarks, ausgedrückt in Millisekunden, die bei einer Last von 5000 Entitäten:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-352">Here is an example graph with measurements taken using some of our microbenchmarks, expressed in milliseconds, with a load of 5000 entities:</span></span>

<span data-ttu-id="6cfbd-353">![Logarithmische Skalierung für .NET 4.5](~/ef6/media/net45logscale.png ".NET 4.5 - logarithmische Skalierung")</span><span class="sxs-lookup"><span data-stu-id="6cfbd-353">![.NET 4.5 logarithmic scale](~/ef6/media/net45logscale.png ".NET 4.5 - logarithmic scale")</span></span>

<span data-ttu-id="6cfbd-354">Beispiel für Suchen zur automatischen Erkennung um Änderungen deaktiviert:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-354">Example of Find with auto-detect changes disabled:</span></span>

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

<span data-ttu-id="6cfbd-355">Was man berücksichtigen die Find-Methode zu verwenden ist:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-355">What you have to consider when using the Find method is:</span></span>

1.  <span data-ttu-id="6cfbd-356">Wenn das Objekt nicht im Cache ist die Vorteile der Suchen negiert werden, aber die Syntax ist noch einfacher, als eine Abfrage nach Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-356">If the object is not in the cache the benefits of Find are negated, but the syntax is still simpler than a query by key.</span></span>
2.  <span data-ttu-id="6cfbd-357">Wenn die automatische Änderungen Erkennung ist aktiviert. die Kosten für die Find-Methode kann durch eine Zehnerpotenz ausgestochen oder sogar noch abhängig von der Komplexität des Modells und die Menge von Entitäten im Objektcache zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-357">If auto detect changes is enabled the cost of the Find method may increase by one order of magnitude, or even more depending on the complexity of your model and the amount of entities in your object cache.</span></span>

<span data-ttu-id="6cfbd-358">Darüber hinaus denken Sie daran, die nur finden, gibt die Entität, die Sie suchen und zwar nicht automatisch laden die zugeordneten Entitäten, wenn sie nicht bereits im Objektcache vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-358">Also, keep in mind that Find only returns the entity you are looking for and it does not automatically loads its associated entities if they are not already in the object cache.</span></span> <span data-ttu-id="6cfbd-359">Wenn Sie zugeordnete Entitäten abrufen möchten, können Sie eine Abfrage nach Schlüssel mit unverzüglichem Laden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-359">If you need to retrieve associated entities, you can use a query by key with eager loading.</span></span> <span data-ttu-id="6cfbd-360">Weitere Informationen finden Sie unter **8.1 Lazy Loading Visual Studio. Eager Loading**.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-360">For more information see **8.1 Lazy Loading vs. Eager Loading**.</span></span>

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a><span data-ttu-id="6cfbd-361">3.1.2 Leistungsprobleme, wenn der Objektcache über viele Entitäten verfügt</span><span class="sxs-lookup"><span data-stu-id="6cfbd-361">3.1.2 Performance issues when the object cache has many entities</span></span>

<span data-ttu-id="6cfbd-362">Objektcache hilft, die um die allgemeine Reaktionsfähigkeit der Entity Framework zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-362">The object cache helps to increase the overall responsiveness of Entity Framework.</span></span> <span data-ttu-id="6cfbd-363">Allerdings wird Wenn Objektcache hat eine große Menge von Entitäten geladen, es bestimmte Vorgänge wie hinzufügen auswirkt, entfernen Sie, suchen Sie, Eintrag, "SaveChanges" und vieles mehr.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-363">However, when the object cache has a very large amount of entities loaded it may affect certain operations such as Add, Remove, Find, Entry, SaveChanges and more.</span></span> <span data-ttu-id="6cfbd-364">Insbesondere werden aufgelistet, die einen Aufruf von DetectChanges Auslösen von sehr großes Objektcaches beeinträchtigt werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-364">In particular, operations that trigger a call to DetectChanges will be negatively affected by very large object caches.</span></span> <span data-ttu-id="6cfbd-365">DetectChanges synchronisiert das Objektdiagramm mit dem Objekt-Status-Manager und seine Leistung wird direkt von der Größe des Objektdiagramms bestimmt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-365">DetectChanges synchronizes the object graph with the object state manager and its performance will determined directly by the size of the object graph.</span></span> <span data-ttu-id="6cfbd-366">Weitere Informationen zu DetectChanges, finden Sie unter [Nachverfolgen von Änderungen in POCO-Entitäten](https://msdn.microsoft.com/library/dd456848.aspx).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-366">For more information about DetectChanges, see [Tracking Changes in POCO Entities](https://msdn.microsoft.com/library/dd456848.aspx).</span></span>

<span data-ttu-id="6cfbd-367">Wenn Sie Entity Framework 6 verwenden zu können, sind Entwickler "AddRange" und "RemoveRange" direkt auf ein "DbSet" anstatt auf eine Auflistung durchlaufen und Aufrufs von Add einmal pro Instanz aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-367">When using Entity Framework 6, developers are able to call AddRange and RemoveRange directly on a DbSet, instead of iterating on a collection and calling Add once per instance.</span></span> <span data-ttu-id="6cfbd-368">Der Vorteil der Verwendung der "Range"-Methoden ist, dass die Kosten für die DetectChanges nur einmal für den gesamten Satz von Entitäten im Gegensatz zu einmal pro jedes hinzugefügte Entität gezahlt wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-368">The advantage of using the range methods is that the cost of DetectChanges is only paid once for the entire set of entities as opposed to once per each added entity.</span></span>

### <a name="32-query-plan-caching"></a><span data-ttu-id="6cfbd-369">3.2 Fragen Sie Zwischenspeichern von Abfrageplänen ab</span><span class="sxs-lookup"><span data-stu-id="6cfbd-369">3.2 Query Plan Caching</span></span>

<span data-ttu-id="6cfbd-370">Beim ersten, die eine Abfrage ausgeführt wird, durchläuft er der internen Plan Compiler übersetzt die grundlegende Abfrage in den Store-Befehl (z. B. die T-SQL die ausgeführt wird, wenn Sie für SQL Server ausgeführt).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-370">The first time a query is executed, it goes through the internal plan compiler to translate the conceptual query into the store command (for example, the T-SQL which is executed when run against SQL Server).</span></span>  <span data-ttu-id="6cfbd-371">Wenn Zwischenspeichern von Abfrageplänen aktiviert ist, wird der nächsten Ausführung die Abfrage wird ausgeführt im Store Befehl direkt aus dem Abfrageplancache zur Ausführung unter Umgehung des Plan Compilers abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-371">If query plan caching is enabled, the next time the query is executed the store command is retrieved directly from the query plan cache for execution, bypassing the plan compiler.</span></span>

<span data-ttu-id="6cfbd-372">Abfrageplancache wird ObjectContext-Instanzen innerhalb derselben Anwendungsdomäne gemeinsam genutzt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-372">The query plan cache is shared across ObjectContext instances within the same AppDomain.</span></span> <span data-ttu-id="6cfbd-373">Sie müssen nicht auf eine ObjectContext-Instanz zum Zwischenspeichern von Abfrageplänen profitieren enthalten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-373">You don't need to hold onto an ObjectContext instance to benefit from query plan caching.</span></span>

#### <a name="321-some-notes-about-query-plan-caching"></a><span data-ttu-id="6cfbd-374">3.2.1 einige Hinweise zum Planen der Abfrage Zwischenspeichern.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-374">3.2.1 Some notes about Query Plan Caching</span></span>

-   <span data-ttu-id="6cfbd-375">Abfrageplancache wird freigegeben, für alle Typen abgefragt: Entity SQL, LINQ to Entities und CompiledQuery-Objekte.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-375">The query plan cache is shared for all query types: Entity SQL, LINQ to Entities, and CompiledQuery objects.</span></span>
-   <span data-ttu-id="6cfbd-376">Zwischenspeichern von Abfrageplänen ist für Entity SQL-Abfragen, in der Standardeinstellung aktiviert, ob durch eine von "EntityCommand" oder durch eine ObjectQuery ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-376">By default, query plan caching is enabled for Entity SQL queries, whether executed through an EntityCommand or through an ObjectQuery.</span></span> <span data-ttu-id="6cfbd-377">Es ist auch standardmäßig für LINQ to Entities-Abfragen in Entity Framework auf .NET 4.5 und Entity Framework 6 aktiviert</span><span class="sxs-lookup"><span data-stu-id="6cfbd-377">It is also enabled by default for LINQ to Entities queries in Entity Framework on .NET 4.5, and in Entity Framework 6</span></span>
    -   <span data-ttu-id="6cfbd-378">Zwischenspeichern von Abfrageplänen kann deaktiviert werden, durch die EnablePlanCaching-Eigenschaft (auf von "EntityCommand" oder ObjectQuery) auf "false" festlegen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-378">Query plan caching can be disabled by setting the EnablePlanCaching property (on EntityCommand or ObjectQuery) to false.</span></span> <span data-ttu-id="6cfbd-379">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-379">For example:</span></span>
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   <span data-ttu-id="6cfbd-380">Für parametrisierte Abfragen erreichen ändern den Wert des Parameters dennoch die zwischengespeicherte Abfrage.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-380">For parameterized queries, changing the parameter's value will still hit the cached query.</span></span> <span data-ttu-id="6cfbd-381">Aber eine parameterfacets (z. B. Größe, Genauigkeit oder Skala) ändern, einen anderen Eintrag im Cache ist erreicht.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-381">But changing a parameter's facets (for example, size, precision, or scale) will hit a different entry in the cache.</span></span>
-   <span data-ttu-id="6cfbd-382">Verwendung von Entity SQL ist die Abfragezeichenfolge Teil des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-382">When using Entity SQL, the query string is part of the key.</span></span> <span data-ttu-id="6cfbd-383">Ändern die Abfrage überhaupt führt zu mehrere Cacheeinträge, auch wenn die Abfragen funktionell gleichwertig sind.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-383">Changing the query at all will result in different cache entries, even if the queries are functionally equivalent.</span></span> <span data-ttu-id="6cfbd-384">Dies schließt Änderungen, die Groß-/Kleinschreibung oder ein Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-384">This includes changes to casing or whitespace.</span></span>
-   <span data-ttu-id="6cfbd-385">Wenn Sie LINQ verwenden, wird die Abfrage verarbeitet, um einen Teil des Schlüssels zu generieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-385">When using LINQ, the query is processed to generate a part of the key.</span></span> <span data-ttu-id="6cfbd-386">Ändern des LINQ-Ausdrucks wird daher einen anderen Schlüssel generieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-386">Changing the LINQ expression will therefore generate a different key.</span></span>
-   <span data-ttu-id="6cfbd-387">Weitere technische Einschränkungen können anfallen. Weitere Informationen finden Sie in der Autocompiled Abfragen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-387">Other technical limitations may apply; see Autocompiled Queries for more details.</span></span>

#### <a name="322------cache-eviction-algorithm"></a><span data-ttu-id="6cfbd-388">3.2.2 Cache Entfernung-Algorithmus</span><span class="sxs-lookup"><span data-stu-id="6cfbd-388">3.2.2      Cache eviction algorithm</span></span>

<span data-ttu-id="6cfbd-389">Verstehen, wie die internen Algorithmus funktioniert Sie zum Aktivieren oder deaktivieren Zwischenspeichern von Abfrageplänen herausfinden können.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-389">Understanding how the internal algorithm works will help you figure out when to enable or disable query plan caching.</span></span> <span data-ttu-id="6cfbd-390">Der Cleanup-Algorithmus sieht folgendermaßen aus:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-390">The cleanup algorithm is as follows:</span></span>

1.  <span data-ttu-id="6cfbd-391">Sobald der Cache über eine festgelegte Anzahl von Einträgen (800) enthält, beginnen wir mit einen Timer an, der in regelmäßigen Abständen (einmal pro Minute) des Caches führt ein Sweep.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-391">Once the cache contains a set number of entries (800), we start a timer that periodically (once-per-minute) sweeps the cache.</span></span>
2.  <span data-ttu-id="6cfbd-392">Während der Cache-Sweep-Einträge werden entfernt, aus dem Cache eine LFRU (Least häufig – zuletzt verwendete) Basis.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-392">During cache sweeps, entries are removed from the cache on a LFRU (Least frequently – recently used) basis.</span></span> <span data-ttu-id="6cfbd-393">Dieser Algorithmus berücksichtigt Trefferanzahl und der ALTER bei der Entscheidung, welche Einträge ausgeworfen werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-393">This algorithm takes both hit count and age into account when deciding which entries are ejected.</span></span>
3.  <span data-ttu-id="6cfbd-394">Am Ende der einzelnen Cache löschen enthält der Cache erneut 800 Einträge.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-394">At the end of each cache sweep, the cache again contains 800 entries.</span></span>

<span data-ttu-id="6cfbd-395">Alle Cacheeinträge werden gleich behandelt werden, beim Ermitteln der Einträge zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-395">All cache entries are treated equally when determining which entries to evict.</span></span> <span data-ttu-id="6cfbd-396">Dies bedeutet, dass der Speicherbefehl für eine CompiledQuery gleichen Wahrscheinlichkeit Entfernung wie der Speicherbefehl für eine Entity SQL-Abfrage.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-396">This means the store command for a CompiledQuery has the same chance of eviction as the store command for an Entity SQL query.</span></span>

<span data-ttu-id="6cfbd-397">Beachten Sie, dass der Cache Entfernung Timer gestartet ist, 800 Entitäten vorhanden sind, im Cache, aber der Cache ist nur eine Komprimierung 60 Sekunden, nachdem dieser Timer gestartet wurde.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-397">Note that the cache eviction timer is kicked in when there are 800 entities in the cache, but the cache is only swept 60 seconds after this timer is started.</span></span> <span data-ttu-id="6cfbd-398">Das bedeutet, dass für bis zu 60 Sekunden Ihres Caches wachsen kann, um sehr groß sein.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-398">That means that for up to 60 seconds your cache may grow to be quite large.</span></span>

#### <a name="323-------test-metrics-demonstrating-query-plan-caching-performance"></a><span data-ttu-id="6cfbd-399">3.2.3 Testmetriken Sie Demonstration Leistung Zwischenspeichern von Abfrageplänen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-399">3.2.3       Test Metrics demonstrating query plan caching performance</span></span>

<span data-ttu-id="6cfbd-400">Um die Auswirkungen auf die Leistung Ihrer Anwendung Zwischenspeichern von Abfrageplänen zu demonstrieren, ausgeführt, wir einen Test, in dem wir eine Anzahl von Entity SQL-Abfragen für das Microsoft Navision-Modell ausgeführt haben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-400">To demonstrate the effect of query plan caching on your application's performance, we performed a test where we executed a number of Entity SQL queries against the Navision model.</span></span> <span data-ttu-id="6cfbd-401">Finden Sie im Anhang eine Beschreibung des Modells Navision und die Typen von Abfragen, die ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-401">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="6cfbd-402">In diesem Test wir zunächst die Liste der Abfragen durchlaufen und jeweils einmal ausgeführt, um sie mit dem Cache hinzuzufügen (sofern es sich um eine Zwischenspeicherung aktiviert ist).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-402">In this test, we first iterate through the list of queries and execute each one once to add them to the cache (if caching is enabled).</span></span> <span data-ttu-id="6cfbd-403">Dieser Schritt ist untimed.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-403">This step is untimed.</span></span> <span data-ttu-id="6cfbd-404">Als Nächstes Standbymodus wir den Hauptthread für mehr als 60 Sekunden zum Cache sweeping zum durchgeführt werden; zum Schluss durchlaufen wir die Liste eine 2. Ausführungsdauer die zwischengespeicherten Abfragen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-404">Next, we sleep the main thread for over 60 seconds to allow cache sweeping to take place; finally, we iterate through the list a 2nd time to execute the cached queries.</span></span> <span data-ttu-id="6cfbd-405">Darüber hinaus ist er SQL Server-Plancache geleert, bevor jede Gruppe von Abfragen ausgeführt wird, so, dass die Häufigkeit, mit die wir genau erhalten den Vorteil, dass vom Abfrageplancache angezeigt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-405">Additionally, he SQL Server plan cache is flushed before each set of queries is executed so that the times we obtain accurately reflect the benefit given by the query plan cache.</span></span>

##### <a name="3231-------test-results"></a><span data-ttu-id="6cfbd-406">3.2.3.1 "Testergebnisse"</span><span class="sxs-lookup"><span data-stu-id="6cfbd-406">3.2.3.1       Test Results</span></span>

| <span data-ttu-id="6cfbd-407">Test</span><span class="sxs-lookup"><span data-stu-id="6cfbd-407">Test</span></span>                                                                   | <span data-ttu-id="6cfbd-408">EF5 kein Cache</span><span class="sxs-lookup"><span data-stu-id="6cfbd-408">EF5 no cache</span></span> | <span data-ttu-id="6cfbd-409">EF5 zwischengespeichert</span><span class="sxs-lookup"><span data-stu-id="6cfbd-409">EF5 cached</span></span> | <span data-ttu-id="6cfbd-410">EF6 kein Cache</span><span class="sxs-lookup"><span data-stu-id="6cfbd-410">EF6 no cache</span></span> | <span data-ttu-id="6cfbd-411">EF6 zwischengespeichert</span><span class="sxs-lookup"><span data-stu-id="6cfbd-411">EF6 cached</span></span> |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| <span data-ttu-id="6cfbd-412">Auflisten aller 18723 Abfragen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-412">Enumerating all 18723 queries</span></span>                                          | <span data-ttu-id="6cfbd-413">124</span><span class="sxs-lookup"><span data-stu-id="6cfbd-413">124</span></span>          | <span data-ttu-id="6cfbd-414">125.4</span><span class="sxs-lookup"><span data-stu-id="6cfbd-414">125.4</span></span>      | <span data-ttu-id="6cfbd-415">124,3</span><span class="sxs-lookup"><span data-stu-id="6cfbd-415">124.3</span></span>        | <span data-ttu-id="6cfbd-416">125.3</span><span class="sxs-lookup"><span data-stu-id="6cfbd-416">125.3</span></span>      |
| <span data-ttu-id="6cfbd-417">Vermeiden Sweep (nur die ersten 800 Abfragen, unabhängig von der Komplexität)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-417">Avoiding sweep (just the first 800 queries, regardless of complexity)</span></span>  | <span data-ttu-id="6cfbd-418">41.7</span><span class="sxs-lookup"><span data-stu-id="6cfbd-418">41.7</span></span>         | <span data-ttu-id="6cfbd-419">5.5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-419">5.5</span></span>        | <span data-ttu-id="6cfbd-420">40,5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-420">40.5</span></span>         | <span data-ttu-id="6cfbd-421">5.4</span><span class="sxs-lookup"><span data-stu-id="6cfbd-421">5.4</span></span>        |
| <span data-ttu-id="6cfbd-422">Nur die AggregatingSubtotals Abfragen (178 insgesamt – wodurch Sweep vermieden werden)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-422">Just the AggregatingSubtotals queries (178 total - which avoids sweep)</span></span> | <span data-ttu-id="6cfbd-423">39,5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-423">39.5</span></span>         | <span data-ttu-id="6cfbd-424">4.5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-424">4.5</span></span>        | <span data-ttu-id="6cfbd-425">38.1</span><span class="sxs-lookup"><span data-stu-id="6cfbd-425">38.1</span></span>         | <span data-ttu-id="6cfbd-426">4.6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-426">4.6</span></span>        |

<span data-ttu-id="6cfbd-427">*Alle Uhrzeiten in Sekunden.*</span><span class="sxs-lookup"><span data-stu-id="6cfbd-427">*All times in seconds.*</span></span>

<span data-ttu-id="6cfbd-428">Moralische - beim Ausführen von losen der unterschiedlichen Abfragen (z. B. Abfragen dynamisch erstellt), caching nicht unterstützen, und der resultierende Leerung des Cache können Sie die Abfragen, die profitieren, dass die meisten Zwischenspeichern von Abfrageplänen aus tatsächlich beibehalten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-428">Moral - when executing lots of distinct queries (for example,  dynamically created queries), caching doesn't help and the resulting flushing of the cache can keep the queries that would benefit the most from plan caching from actually using it.</span></span>

<span data-ttu-id="6cfbd-429">Die AggregatingSubtotals-Abfragen sind sehr komplexe Abfragen, die, denen wir mit getestet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-429">The AggregatingSubtotals queries are the most complex of the queries we tested with.</span></span> <span data-ttu-id="6cfbd-430">Wie erwartet desto komplexer ist die Abfrage, den weitere Vorteil von Zwischenspeichern von Abfrageplänen wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-430">As expected, the more complex the query is, the more benefit you will see from query plan caching.</span></span>

<span data-ttu-id="6cfbd-431">Da eine CompiledQuery wirklich eine LINQ-Abfrage mit einem Plan zwischengespeichert ist, sollte der Vergleich eine CompiledQuery im Vergleich zu den entsprechenden Entity SQL-Abfrage ähnliche Ergebnisse haben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-431">Because a CompiledQuery is really a LINQ query with its plan cached, the comparison of a CompiledQuery versus the equivalent Entity SQL query should have similar results.</span></span> <span data-ttu-id="6cfbd-432">In der Tat verfügt eine app viele dynamische Entity SQL-Abfragen, bewirkt füllen den Cache mit Abfragen auch CompiledQueries "dekompiliert", wenn sie aus dem Cache geleert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-432">In fact, if an app has lots of dynamic Entity SQL queries, filling the cache with queries will also effectively cause CompiledQueries to “decompile” when they are flushed from the cache.</span></span> <span data-ttu-id="6cfbd-433">In diesem Szenario kann die Leistung verbessert werden durch das Deaktivieren der Zwischenspeicherung für die dynamische Abfragen, die CompiledQueries zu priorisieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-433">In this scenario, performance may be improved by disabling caching on the dynamic queries to prioritize the CompiledQueries.</span></span> <span data-ttu-id="6cfbd-434">Besser noch, natürlich wäre, Schreiben Sie die app, um parametrisierte Abfragen anstelle von dynamischen Abfragen verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-434">Better yet, of course, would be to rewrite the app to use parameterized queries instead of dynamic queries.</span></span>

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a><span data-ttu-id="6cfbd-435">3.3 Verwendung von CompiledQuery zur Verbesserung der Leistung mit LINQ-Abfragen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-435">3.3 Using CompiledQuery to improve performance with LINQ queries</span></span>

<span data-ttu-id="6cfbd-436">Unsere Tests anzugeben, dass mit der CompiledQuery ein Vorteil von 7 % über Autocompiled LINQ-Abfragen bieten kann; Das heißt, Sie 7 % weniger Zeit für die Ausführung von Code aus dem Entity Framework-Stapel beschäftigen. Es bedeutet nicht, dass Ihre Anwendung 7 % schneller ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-436">Our tests indicate that using CompiledQuery can bring a benefit of 7% over autocompiled LINQ queries; this means that you’ll spend 7% less time executing code from the Entity Framework stack; it does not mean your application will be 7% faster.</span></span> <span data-ttu-id="6cfbd-437">Im Allgemeinen kann die Kosten für das Schreiben und pflegen von CompiledQuery-Objekte in EF 5.0 sollte das Problem im Vergleich zu den Vorteilen nicht.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-437">Generally speaking, the cost of writing and maintaining CompiledQuery objects in EF 5.0 may not be worth the trouble when compared to the benefits.</span></span> <span data-ttu-id="6cfbd-438">Ihr Bedarf kann variieren, Übung also diese Option aus, wenn das Projekt, den zusätzliche Push erfordert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-438">Your mileage may vary, so exercise this option if your project requires the extra push.</span></span> <span data-ttu-id="6cfbd-439">Beachten Sie, dass CompiledQueries nur kompatibel mit ObjectContext abgeleiteten-Modellen und nicht kompatibel mit Modellen "DbContext" abgeleitet sind.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-439">Note that CompiledQueries are only compatible with ObjectContext-derived models, and not compatible with DbContext-derived models.</span></span>

<span data-ttu-id="6cfbd-440">Weitere Informationen zum Erstellen und Aufrufen einer CompiledQuery finden Sie unter [kompilierte Abfragen (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-440">For more information on creating and invoking a CompiledQuery, see [Compiled Queries (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span></span>

<span data-ttu-id="6cfbd-441">Es gibt zwei Überlegungen haben Sie an, die beim Verwenden einer CompiledQuery, nämlich die Anforderung, verwenden Sie statische Instanzen und die Probleme, dass sie zusammensetzbarkeit haben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-441">There are two considerations you have to take when using a CompiledQuery, namely the requirement to use static instances and the problems they have with composability.</span></span> <span data-ttu-id="6cfbd-442">Hier folgt eine ausführliche Erläuterung dieser beiden Aspekte.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-442">Here follows an in-depth explanation of these two considerations.</span></span>

#### <a name="331-------use-static-compiledquery-instances"></a><span data-ttu-id="6cfbd-443">3.3.1 verwenden Sie statische CompiledQuery-Instanzen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-443">3.3.1       Use static CompiledQuery instances</span></span>

<span data-ttu-id="6cfbd-444">Kompilieren eine LINQ-Abfrage ein sehr zeitaufwendiger Prozess daher möchten wir nicht dafür, jedem müssen wir zum Abrufen von Daten aus der Datenbank.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-444">Since compiling a LINQ query is a time-consuming process, we don’t want to do it every time we need to fetch data from the database.</span></span> <span data-ttu-id="6cfbd-445">CompiledQuery-Instanzen ermöglichen Ihnen einmal kompilieren und führen mehrere Male, aber Sie vorsichtig sein müssen, und beschaffen, um dieselbe Instanz CompiledQuery jedes Mal statt kompilieren immer wieder erneut zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-445">CompiledQuery instances allow you to compile once and run multiple times, but you have to be careful and procure to re-use the same CompiledQuery instance every time instead of compiling it over and over again.</span></span> <span data-ttu-id="6cfbd-446">Die Verwendung der statischen Member zum Speichern der CompiledQuery-Instanzen ist erforderlich; Andernfalls wird keine Vorteile nicht angezeigt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-446">The use of static members to store the CompiledQuery instances becomes necessary; otherwise you won’t see any benefit.</span></span>

<span data-ttu-id="6cfbd-447">Nehmen wir beispielsweise an, dass die Seite den folgenden Methodentext, behandeln die Anzeige von Produkten für die ausgewählte Kategorie verfügt:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-447">For example, suppose your page has the following method body to handle displaying the products for the selected category:</span></span>

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

<span data-ttu-id="6cfbd-448">In diesem Fall erstellen Sie eine neue Instanz der CompiledQuery im laufenden Betrieb jedes Mal, wenn die Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-448">In this case, you will create a new CompiledQuery instance on the fly every time the method is called.</span></span> <span data-ttu-id="6cfbd-449">Statt die Leistungsvorteile durch Aufrufen der entsprechenden Speicherbefehl Abfrageplancache befinden, wird der Plan-Compiler der CompiledQuery durchlaufen, jedes Mal eine neue Instanz erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-449">Instead of seeing performance benefits by retrieving the store command from the query plan cache, the CompiledQuery will go through the plan compiler every time a new instance is created.</span></span> <span data-ttu-id="6cfbd-450">In der Tat werden Sie Entwurfsausdruck werden Ihrem Abfrageplancache mit einem neuen CompiledQuery-Eintrag jedes Mal, wenn die Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-450">In fact, you will be polluting your query plan cache with a new CompiledQuery entry every time the method is called.</span></span>

<span data-ttu-id="6cfbd-451">Sie möchten stattdessen erstellen eine statische Instanz der kompilierten Abfrage aus, damit Sie die gleiche kompilierte Abfrage aufrufen, jedes Mal, wenn die Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-451">Instead, you want to create a static instance of the compiled query, so you are invoking the same compiled query every time the method is called.</span></span> <span data-ttu-id="6cfbd-452">Eine Möglichkeit, durch das Hinzufügen der CompiledQuery-Instanz als ein Mitglied der Objektkontext ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-452">One way to so this is by adding the CompiledQuery instance as a member of your object context.</span></span>  <span data-ttu-id="6cfbd-453">Sie können Aufgaben klicken Sie dann eine wenig klarer vornehmen, durch den Zugriff auf die CompiledQuery über eine Hilfsmethode:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-453">You can then make things a little cleaner by accessing the CompiledQuery through a helper method:</span></span>

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

<span data-ttu-id="6cfbd-454">Diese Hilfsmethode würde wie folgt aufgerufen werden:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-454">This helper method would be invoked as follows:</span></span>

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-------composing-over-a-compiledquery"></a><span data-ttu-id="6cfbd-455">3.3.2 zusammenstellen über eine CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="6cfbd-455">3.3.2       Composing over a CompiledQuery</span></span>

<span data-ttu-id="6cfbd-456">Die Möglichkeit, die für alle LINQ-Abfrage verfasst ist äußerst nützlich. zu diesem Zweck einfach Methode aufgerufen, um eine nach der das IQueryable-Objekt wie z. B. *Skip()"* oder *Count()*.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-456">The ability to compose over any LINQ query is extremely useful; to do this, you simply invoke a method after the IQueryable such as *Skip()* or *Count()*.</span></span> <span data-ttu-id="6cfbd-457">Jedoch im Grunde genommen also tun, wird ein neues "IQueryable"-Objekt zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-457">However, doing so essentially returns a new IQueryable object.</span></span> <span data-ttu-id="6cfbd-458">Zwar gibt es nichts zu technisch zusammenstellen, die über eine CompiledQuery verhindern, erfordert der Generierung eines neuen "IQueryable"-Objekts, das bewirkt dies übergeben, durch den Compiler Plan erneut an.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-458">While there’s nothing to stop you technically from composing over a CompiledQuery, doing so will cause the generation of a new IQueryable object that requires passing through the plan compiler again.</span></span>

<span data-ttu-id="6cfbd-459">Einige Komponenten werden Nutzen aus "IQueryable"-Objekten, die erweiterte Funktionalität zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-459">Some components will make use of composed IQueryable objects to enable advanced functionality.</span></span> <span data-ttu-id="6cfbd-460">Beispiel: ASP. NET GridView kann Daten an ein IQueryable-Objekt über die SelectMethod-Eigenschaft gebunden werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-460">For example, ASP.NET’s GridView can be data-bound to an IQueryable object via the SelectMethod property.</span></span> <span data-ttu-id="6cfbd-461">Das GridView wird dann für diese "IQueryable"-Objekt zu sortieren und paging für das Datenmodell verfasst.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-461">The GridView will then compose over this IQueryable object to allow sorting and paging over the data model.</span></span> <span data-ttu-id="6cfbd-462">Wie Sie sehen können, verwenden eine CompiledQuery für GridView würde nicht erreicht, der die kompilierte Abfrage jedoch erzeugt eine neue Autocompiled-Abfrage.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-462">As you can see, using a CompiledQuery for the GridView would not hit the compiled query but would generate a new autocompiled query.</span></span>

<span data-ttu-id="6cfbd-463">Die Customer Advisory Team erläutert dies in ihren Blogbeitrag "Mögliche Leistung Probleme mit kompilierte LINQ-Abfrage erneut kompiliert wird": <http://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/potential-performance-issues-with-compiled-linq-query-re-compiles.aspx>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-463">The Customer Advisory Team discusses this in their "Potential Performance Issues with Compiled LINQ Query Re-Compiles" blog post: <http://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/potential-performance-issues-with-compiled-linq-query-re-compiles.aspx>.</span></span>

<span data-ttu-id="6cfbd-464">Einem zentralen Ort, in denen dies unter Umständen auftreten, ist beim progressiven Filter auf eine Abfrage hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-464">One place where you may run into this is when adding progressive filters to a query.</span></span> <span data-ttu-id="6cfbd-465">Nehmen wir beispielsweise an, dass Sie eine Kundenseite mit verschiedene Dropdownlisten für die optionalen Filtern (z. B. "Land" und "OrdersCount") konnten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-465">For example, suppose you had a Customers page with several drop-down lists for optional filters (for example, Country and OrdersCount).</span></span> <span data-ttu-id="6cfbd-466">Sie können diese Filter für die "IQueryable" Ergebnisse von einer CompiledQuery verfassen, aber dies wird in der neuen Abfrage durchlaufen des Plan-Compilers, jedes Mal, wenn Sie es ausführen, führen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-466">You can compose these filters over the IQueryable results of a CompiledQuery, but doing so will result in the new query going through the plan compiler every time you execute it.</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="6cfbd-467">Um diese erneute Kompilierung zu vermeiden, können Sie umschreiben, dass der CompiledQuery, um die mögliche Filter zu berücksichtigen:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-467">To avoid this re-compilation, you can rewrite the CompiledQuery to take the possible filters into account:</span></span>

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

<span data-ttu-id="6cfbd-468">Die in der Benutzeroberfläche wie aufgerufen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-468">Which would be invoked in the UI like:</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="6cfbd-469">Ein Nachteil hierbei ist generierten Speicherbefehl weisen stets die Filter mit der null-Überprüfungen, sollten Sie werden jedoch recht einfach, für den Datenbankserver zur Optimierung:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-469">A tradeoff here is the generated store command will always have the filters with the null checks, but these should be fairly simple for the database server to optimize:</span></span>

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a><span data-ttu-id="6cfbd-470">3.4-Metadaten-Zwischenspeicherung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-470">3.4 Metadata caching</span></span>

<span data-ttu-id="6cfbd-471">Das Entity Framework unterstützt auch das Zwischenspeichern von Metadaten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-471">The Entity Framework also supports Metadata caching.</span></span> <span data-ttu-id="6cfbd-472">Dies ist im Wesentlichen der Typinformationen und Zuordnungsinformationen und Typ der Datenbank über verschiedene Verbindungen demselben Modell zwischengespeichert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-472">This is essentially caching of type information and type-to-database mapping information across different connections to the same model.</span></span> <span data-ttu-id="6cfbd-473">Metadatencache ist pro Anwendungsdomäne eindeutig.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-473">The Metadata cache is unique per AppDomain.</span></span>

#### <a name="341-metadata-caching-algorithm"></a><span data-ttu-id="6cfbd-474">3.4.1 Metadaten-Caching-Algorithmus</span><span class="sxs-lookup"><span data-stu-id="6cfbd-474">3.4.1 Metadata Caching algorithm</span></span>

1.  <span data-ttu-id="6cfbd-475">Informationen zu Metadaten für ein Modell wird in eine ItemCollection für die einzelnen EntityConnection-Objekt gespeichert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-475">Metadata information for a model is stored in an ItemCollection for each EntityConnection.</span></span>
    -   <span data-ttu-id="6cfbd-476">Nebenbei bemerkt gibt es verschiedene ItemCollection-Objekte für die verschiedenen Teile des Modells.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-476">As a side note, there are different ItemCollection objects for different parts of the model.</span></span> <span data-ttu-id="6cfbd-477">StoreItemCollections enthält beispielsweise die Informationen über das Datenbankmodell; ObjectItemCollection zurück enthält Informationen über das Datenmodell. EdmItemCollection enthält Informationen über das konzeptionelle Modell.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-477">For example, StoreItemCollections contains the information about the database model; ObjectItemCollection contains information about the data model; EdmItemCollection contains information about the conceptual model.</span></span>

2.  <span data-ttu-id="6cfbd-478">Wenn zwei Verbindungen die gleiche Verbindungszeichenfolge verwenden, werden sie die gleiche ItemCollection Instanz freigeben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-478">If two connections use the same connection string, they will share the same ItemCollection instance.</span></span>
3.  <span data-ttu-id="6cfbd-479">Funktionell gleichwertig, aber textlich unterschiedliche Verbindungszeichenfolgen können dazu führen, dass andere Metadaten-Caches.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-479">Functionally equivalent but textually different connection strings may result in different metadata caches.</span></span> <span data-ttu-id="6cfbd-480">Wir Verbindungszeichenfolgen, mit einem Token versehen einfach ändern der Reihenfolge der Token in den freigegebenen Metadaten führen soll.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-480">We do tokenize connection strings, so simply changing the order of the tokens should result in shared metadata.</span></span> <span data-ttu-id="6cfbd-481">Jedoch zwei Verbindungszeichenfolgen, die funktionell identisch erscheinen möglicherweise nicht ausgewertet werden als identisch nach der Zerlegung in Token.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-481">But two connection strings that seem functionally the same may not be evaluated as identical after tokenization.</span></span>
4.  <span data-ttu-id="6cfbd-482">Die ItemCollection wird in regelmäßigen Abständen für die Verwendung überprüft.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-482">The ItemCollection is periodically checked for use.</span></span> <span data-ttu-id="6cfbd-483">Wenn festgestellt wird, dass ein Arbeitsbereich nicht zuletzt zugegriffen wurde, wird es für die Bereinigung auf der nächsten Cache Sweep gekennzeichnet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-483">If it is determined that a workspace has not been accessed recently, it will be marked for cleanup on the next cache sweep.</span></span>
5.  <span data-ttu-id="6cfbd-484">Allein durch das Erstellen einer EntityConnection-Objekt wird dazu führen, dass einem veralteten Metadatencache erstellt werden (obwohl die elementauflistungen darin nicht initialisiert werden, bis die Verbindung geöffnet wird).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-484">Merely creating an EntityConnection will cause a metadata cache to be created (though the item collections in it will not be initialized until the connection is opened).</span></span> <span data-ttu-id="6cfbd-485">Dieser Arbeitsbereich bleibt im Arbeitsspeicher, bis die caching-Algorithmus feststellt, dass sie nicht "in Verwendung" ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-485">This workspace will remain in-memory until the caching algorithm determines it is not “in use”.</span></span>

<span data-ttu-id="6cfbd-486">Die Customer Advisory Team verfügt über einen Blogbeitrag, der beschreibt, enthält einen Verweis auf eine ItemCollection um "als veraltet" zu vermeiden, wenn Sie große Modelle verwenden geschrieben: \<http://blogs.msdn.com/b/appfabriccat/archive/2010/10/22/metadataworkspace-reference-in-wcf-services.aspx>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-486">The Customer Advisory Team has written a blog post that describes holding a reference to an ItemCollection in order to avoid "deprecation" when using large models: \<http://blogs.msdn.com/b/appfabriccat/archive/2010/10/22/metadataworkspace-reference-in-wcf-services.aspx>.</span></span>

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a><span data-ttu-id="6cfbd-487">3.4.2 die Beziehung zwischen Metadaten und Abfragen Planen der Zwischenspeicherung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-487">3.4.2 The relationship between Metadata Caching and Query Plan Caching</span></span>

<span data-ttu-id="6cfbd-488">Die Abfrage-Plan-Cache-Instanz befindet sich in MetadataWorkspaces ItemCollection von Store-Typen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-488">The query plan cache instance lives in the MetadataWorkspace's ItemCollection of store types.</span></span> <span data-ttu-id="6cfbd-489">Dies bedeutet, dass zwischengespeicherte Speicherbefehle für Abfragen in einem Kontext mit einem bestimmten MetadataWorkspace instanziiert verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-489">This means that cached store commands will be used for queries against any context instantiated using a given MetadataWorkspace.</span></span> <span data-ttu-id="6cfbd-490">Dies bedeutet auch, wenn Sie zwei Verbindungszeichenfolgen verwenden, die unterscheiden sich leicht aus, und nach der Tokenisierung stimmen nicht überein, Sie verschiedene Abfragen, die Cache-Instanzen zu planen müssen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-490">It also means that if you have two connections strings that are slightly different and don't match after tokenizing, you will have different query plan cache instances.</span></span>

### <a name="35-results-caching"></a><span data-ttu-id="6cfbd-491">3.5 Ergebnisse zwischenspeichern</span><span class="sxs-lookup"><span data-stu-id="6cfbd-491">3.5 Results caching</span></span>

<span data-ttu-id="6cfbd-492">Mit Ergebnissen Zwischenspeichern (auch bekannt als "Second-Level-caching") halten Sie die Ergebnisse von Abfragen in einem lokalen Cache.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-492">With results caching (also known as "second-level caching"), you keep the results of queries in a local cache.</span></span> <span data-ttu-id="6cfbd-493">Wenn eine Abfrage ausgegeben wird, sehen Sie sich zunächst, wenn die Ergebnisse vor dem Sie eine Abfrage für den Speicher lokal verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-493">When issuing a query, you first see if the results are available locally before you query against the store.</span></span> <span data-ttu-id="6cfbd-494">Während der Ergebnisse, die Zwischenspeicherung direkt von Entity Framework unterstützt werden, ist es möglich, einen Cache zweiten Ebenen hinzufügen, indem Sie mithilfe eines Anbieters umschließen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-494">While results caching isn't directly supported by Entity Framework, it's possible to add a second level cache by using a wrapping provider.</span></span> <span data-ttu-id="6cfbd-495">Ein Beispiel-Wrapping-Anbieter mit einem Cache zweiter Ebene ist die Alachisoft [Cache zweiter Ebene in Entity Framework auf der Grundlage von NCache](http://www.alachisoft.com/ncache/entity-framework.html).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-495">An example wrapping provider with a second-level cache is Alachisoft's [Entity Framework Second Level Cache based on NCache](http://www.alachisoft.com/ncache/entity-framework.html).</span></span>

<span data-ttu-id="6cfbd-496">Diese Implementierung der Zwischenspeicherung auf zweiter Ebene ist eine eingefügte verfügbar, die direkt nach der LINQ-Ausdruck ausgewertet wurde (und Funcletized) und der Abfrageausführungsplan berechnet oder abgerufen, die aus dem Cache auf oberster Ebene.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-496">This implementation of second-level caching is an injected functionality that takes place after the LINQ expression has been evaluated (and funcletized) and the query execution plan is computed or retrieved from the first-level cache.</span></span> <span data-ttu-id="6cfbd-497">Cache zweiter Ebene werden dann nur die Ergebnisse des raw-Datenbank gespeichert, damit die Materialization-Pipeline danach immer noch ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-497">The second-level cache will then store only the raw database results, so the materialization pipeline still executes afterwards.</span></span>

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a><span data-ttu-id="6cfbd-498">3.5.1 Weitere Verweise für Ergebnisse zwischenspeichern, wenn die Wrapping-Anbieter</span><span class="sxs-lookup"><span data-stu-id="6cfbd-498">3.5.1 Additional references for results caching with the wrapping provider</span></span>

-   <span data-ttu-id="6cfbd-499">Julie Lerman hat einen "Second-Level-Zwischenspeicherung in Entity Framework und Windows Azure" MSDN-Artikel geschrieben, der Vorgehensweise beim Aktualisieren des Wrapping-Beispielanbieters zum Verwenden von Windows Server AppFabric caching enthält: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-499">Julie Lerman has written a "Second-Level Caching in Entity Framework and Windows Azure" MSDN article that includes how to update the sample wrapping provider to use Windows Server AppFabric caching: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span></span>
-   <span data-ttu-id="6cfbd-500">Wenn Sie mit Entity Framework 5 arbeiten, hat das Teamblog einen Beitrag, der beschreibt, wie Sie die Dinge, die mit der caching-Anbieter für Entity Framework 5 ausgeführt werden: \<http://blogs.msdn.com/b/adonet/archive/2010/09/13/ef-caching-with-jarek-kowalski-s-provider.aspx>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-500">If you are working with Entity Framework 5, the team blog has a post that describes how to get things running with the caching provider for Entity Framework 5: \<http://blogs.msdn.com/b/adonet/archive/2010/09/13/ef-caching-with-jarek-kowalski-s-provider.aspx>.</span></span> <span data-ttu-id="6cfbd-501">Darüber hinaus eine T4-Vorlage zum Hinzufügen von der Ebene 2. caching zu Ihrem Projekt automatisieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-501">It also includes a T4 template to help automate adding the 2nd-level caching to your project.</span></span>

## <a name="4-autocompiled-queries"></a><span data-ttu-id="6cfbd-502">4 Autocompiled Abfragen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-502">4 Autocompiled Queries</span></span>

<span data-ttu-id="6cfbd-503">Wenn eine Abfrage für eine Datenbank mit Entity Framework ausgegeben wird, muss es eine Reihe von Schritten durchlaufen, bevor tatsächlich materialisieren die Ergebnisse; Ein solcher Schritt ist die Abfragekompilierung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-503">When a query is issued against a database using Entity Framework, it must go through a series of steps before actually materializing the results; one such step is Query Compilation.</span></span> <span data-ttu-id="6cfbd-504">Entity SQL-Abfragen wurden auf gute Leistung gezeigt hat, wie sie automatisch zwischengespeichert werden, damit die zweites oder drittes Mal ausführen derselben Abfrage können sie überspringen den Plan-Compiler und verwenden Sie stattdessen den zwischengespeicherten Plan bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-504">Entity SQL queries were known to have good performance as they are automatically cached, so the second or third time you execute the same query it can skip the plan compiler and use the cached plan instead.</span></span>

<span data-ttu-id="6cfbd-505">Entitätsframework 5 wurde die automatische Zwischenspeicherung für LINQ to Entities-Abfragen sowie eingeführt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-505">Entity Framework 5 introduced automatic caching for LINQ to Entities queries as well.</span></span> <span data-ttu-id="6cfbd-506">In früheren Editionen von Entity Framework, erstellen eine CompiledQuery um beschleunigen war der Leistung Ihrer allgemeinen Brauch werden, wie diese LINQ to Entities-Abfrage zwischengespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-506">In past editions of Entity Framework creating a CompiledQuery to speed your performance was a common practice, as this would make your LINQ to Entities query cacheable.</span></span> <span data-ttu-id="6cfbd-507">Da Zwischenspeichern jetzt automatisch ohne eine CompiledQuery durchgeführt wird, rufen wir dieses Feature "Autocompiled Abfragen".</span><span class="sxs-lookup"><span data-stu-id="6cfbd-507">Since caching is now done automatically without the use of a CompiledQuery, we call this feature “autocompiled queries”.</span></span> <span data-ttu-id="6cfbd-508">Zwischenspeichern von Abfrageplänen finden Sie weitere Informationen zu den Abfrageplancache und seine Funktionsweise.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-508">For more information about the query plan cache and its mechanics, see Query Plan Caching.</span></span>

<span data-ttu-id="6cfbd-509">Entitätsframework erkennt, wenn eine Abfrage erforderlich ist, neu kompiliert werden, und führt Sie dies, wenn die Abfrage aufgerufen wird, auch wenn sie vor dem kompiliert wurde, hatte.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-509">Entity Framework detects when a query requires to be recompiled, and does so when the query is invoked even if it had been compiled before.</span></span> <span data-ttu-id="6cfbd-510">Sind allgemeine Bedingungen, unter denen die Abfrage neu kompiliert werden:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-510">Common conditions that cause the query to be recompiled are:</span></span>

-   <span data-ttu-id="6cfbd-511">Ändern die MergeOption für die Abfrage verknüpft ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-511">Changing the MergeOption associated to your query.</span></span> <span data-ttu-id="6cfbd-512">Die Abfrage im Cache nicht verwendet werden, stattdessen die Plan-Compiler werden erneut ausgeführt, und der neu erstellte Plan zwischengespeichert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-512">The cached query will not be used, instead the plan compiler will run again and the newly created plan gets cached.</span></span>
-   <span data-ttu-id="6cfbd-513">Ändern den Wert der ContextOptions.UseCSharpNullComparisonBehavior.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-513">Changing the value of ContextOptions.UseCSharpNullComparisonBehavior.</span></span> <span data-ttu-id="6cfbd-514">Sie erhalten dieselbe Wirkung wie das Ändern der MergeOption.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-514">You get the same effect as changing the MergeOption.</span></span>

<span data-ttu-id="6cfbd-515">Andere Bedingungen können verhindern, dass Ihre Abfrage mit dem Cache.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-515">Other conditions can prevent your query from using the cache.</span></span> <span data-ttu-id="6cfbd-516">Häufige Beispiele sind:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-516">Common examples are:</span></span>

-   <span data-ttu-id="6cfbd-517">Mithilfe von "IEnumerable"&lt;T&gt;. Enthält&lt;&gt;(T-Wert).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-517">Using IEnumerable&lt;T&gt;.Contains&lt;&gt;(T value).</span></span>
-   <span data-ttu-id="6cfbd-518">Verwenden von Funktionen, die Abfragen mit Konstanten zu erzeugen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-518">Using functions that produce queries with constants.</span></span>
-   <span data-ttu-id="6cfbd-519">Verwenden die Eigenschaften eines Objekts nicht zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-519">Using the properties of a non-mapped object.</span></span>
-   <span data-ttu-id="6cfbd-520">Verknüpfen Ihre Abfrage an eine andere Abfrage, die erforderlich sind, neu kompiliert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-520">Linking your query to another query that requires to be recompiled.</span></span>

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a><span data-ttu-id="6cfbd-521">4.1 mithilfe von "IEnumerable"&lt;T&gt;. Enthält&lt;T&gt;(T-Wert)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-521">4.1 Using IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value)</span></span>

<span data-ttu-id="6cfbd-522">Entitätsframework zwischenspeichert keine Abfragen, die "IEnumerable" aufrufen&lt;T&gt;. Enthält&lt;T&gt;(T-Wert) für eine in-Memory-Sammlung, da die Werte der Auflistung als flüchtige betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-522">Entity Framework does not cache queries that invoke IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) against an in-memory collection, since the values of the collection are considered volatile.</span></span> <span data-ttu-id="6cfbd-523">Die folgende Beispielabfrage werden nicht zwischengespeichert werden, damit er immer durch den Plan-Compiler verarbeitet werden:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-523">The following example query will not be cached, so it will always be processed by the plan compiler:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="6cfbd-524">Beachten Sie, dass, die ausgeführt wird, dass Sie die Größe der IEnumerable für enthält die bestimmt, wie schnell oder langsam wie die Abfrage kompiliert wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-524">Note that the size of the IEnumerable against which Contains is executed determines how fast or how slow your query is compiled.</span></span> <span data-ttu-id="6cfbd-525">Bei Verwendung von großen Auflistungen, wie im obigen Beispiel gezeigt kann die Leistung erheblich beeinträchtigt werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-525">Performance can suffer significantly when using large collections such as the one shown in the example above.</span></span>

<span data-ttu-id="6cfbd-526">Entitätsframework 6 enthält Optimierungen, mit der Art "IEnumerable"&lt;T&gt;. Enthält&lt;T&gt;(T-Wert) funktioniert, wenn Abfragen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-526">Entity Framework 6 contains optimizations to the way IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) works when queries are executed.</span></span> <span data-ttu-id="6cfbd-527">Ist des SQL-Codes, der generiert wird, erzeugt viel schneller und besser lesbar und in den meisten Fällen auch führt schneller auf dem Server.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-527">The SQL code that is generated is much faster to produce and more readable, and in most cases it also executes faster in the server.</span></span>

### <a name="42-using-functions-that-produce-queries-with-constants"></a><span data-ttu-id="6cfbd-528">4.2 mithilfe von Funktionen, die Abfragen mit Konstanten erzeugen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-528">4.2 Using functions that produce queries with constants</span></span>

<span data-ttu-id="6cfbd-529">Die Skip()"", "Take()" "," Contains() "und" DefautIfEmpty() LINQ-Operatoren erzeugen nicht SQL-Abfragen mit Parametern aber stattdessen legen Sie die Werte, die als Konstanten an sie übergeben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-529">The Skip(), Take(), Contains() and DefautIfEmpty() LINQ operators do not produce SQL queries with parameters but instead put the values passed to them as constants.</span></span> <span data-ttu-id="6cfbd-530">Aus diesem Grund Abfragen, die andernfalls über identische am Ende die Abfrage Entwurfsausdruck möglicherweise Plancache, sowohl auf dem EF-Stapel als auch auf dem Datenbankserver, und keine reutilized, es sei denn, die gleichen Konstanten in einer nachfolgenden abfrageausführung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-530">Because of this, queries that might otherwise be identical end up polluting the query plan cache, both on the EF stack and on the database server, and do not get reutilized unless the same constants are used in a subsequent query execution.</span></span> <span data-ttu-id="6cfbd-531">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-531">For example:</span></span>

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="6cfbd-532">In diesem Beispiel wird jedes Mal, wenn diese Abfrage mit einem anderen Wert für die Id der Abfrage ausgeführt wird, in einen neuen Plan kompiliert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-532">In this example, each time this query is executed with a different value for id the query will be compiled into a new plan.</span></span>

<span data-ttu-id="6cfbd-533">In bestimmten Achten Sie darauf, die Verwendung von Skip und Take beim Paging.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-533">In particular pay attention to the use of Skip and Take when doing paging.</span></span> <span data-ttu-id="6cfbd-534">In EF6 haben diese Methoden eine Lambda-Überladung, die dadurch des zwischengespeicherten Abfrageplans wiederverwendbare wird, da EF an diese Methoden übergebene Variablen erfassen und auf von ' SqlParameters ' übersetzen kann.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-534">In EF6 these methods have a lambda overload that effectively makes the cached query plan reusable because EF can capture variables passed to these methods and translate them to SQLparameters.</span></span> <span data-ttu-id="6cfbd-535">Dadurch wird auch den Cache übersichtlicher zu halten, da jede Abfrage mit einer anderen Konstanten für überspringen, und ergreifen Sie eine eigene Cacheeintrag des Abfrage-Plan erhalten würden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-535">This also helps keep the cache cleaner since otherwise each query with a different constant for Skip and Take would get its own query plan cache entry.</span></span>

<span data-ttu-id="6cfbd-536">Betrachten Sie den folgenden Code, die nicht optimal, aber dient nur beispielhaft diese Klasse von Abfragen aus:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-536">Consider the following code, which is suboptimal but is only meant to exemplify this class of queries:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="6cfbd-537">Eine schnellere Version der gleichen Code enthält z. B. Aufrufen von Skip mit einem Lambda-Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-537">A faster version of this same code would involve calling Skip with a lambda:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i \< count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="6cfbd-538">Der zweite Codeausschnitt kann bis zu 11 % schneller ausgeführt werden, da der gleiche Abfrageplan verwendet wird, jedes Mal, wenn die Abfrage ausgeführt wird, speichert der CPU-Zeit und vermeidet, den Abfragecache beschädigen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-538">The second snippet may run up to 11% faster because the same query plan is used every time the query is run, which saves CPU time and avoids polluting the query cache.</span></span> <span data-ttu-id="6cfbd-539">Darüber hinaus, da der Parameter zu überspringende in einem Abschluss ist möglicherweise der Code auch jetzt aussehen:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-539">Furthermore, because the parameter to Skip is in a closure the code might as well look like this now:</span></span>

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a><span data-ttu-id="6cfbd-540">4.3 mithilfe der Eigenschaften eines Objekts nicht zugeordnet</span><span class="sxs-lookup"><span data-stu-id="6cfbd-540">4.3 Using the properties of a non-mapped object</span></span>

<span data-ttu-id="6cfbd-541">Wenn eine Abfrage der Eigenschaften eines Objekttyps nicht zugeordnete verwendet, wie Parameter und klicken Sie dann die Abfrage nicht zwischengespeichert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-541">When a query uses the properties of a non-mapped object type as a parameter then the query will not get cached.</span></span> <span data-ttu-id="6cfbd-542">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-542">For example:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

<span data-ttu-id="6cfbd-543">In diesem Beispiel wird davon ausgegangen Sie, dass die Klasse NonMappedType nicht Teil des Modells für die Entität ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-543">In this example, assume that class NonMappedType is not part of the Entity model.</span></span> <span data-ttu-id="6cfbd-544">Diese Abfrage kann leicht geändert werden, um nicht verwenden Sie einen Typ nicht zugeordnet, und verwenden stattdessen eine lokale Variable als Parameter für die Abfrage:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-544">This query can easily be changed to not use a non-mapped type and instead use a local variable as the parameter to the query:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="6cfbd-545">In diesem Fall wird die Abfrage wird in der Lage, zwischengespeichert, abrufen und aus dem Plancache für die Abfrage profitiert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-545">In this case, the query will be able to get cached and will benefit from the query plan cache.</span></span>

### <a name="44-linking-to-queries-that-require-recompiling"></a><span data-ttu-id="6cfbd-546">4.4 Verknüpfen mit Abfragen, für die erneute Kompilierung erforderlich</span><span class="sxs-lookup"><span data-stu-id="6cfbd-546">4.4 Linking to queries that require recompiling</span></span>

<span data-ttu-id="6cfbd-547">Entsprechend dem gleichen Beispiel wie oben beschrieben Wenn Sie eine zweite Abfrage, die auf einer Abfrage, die neu kompiliert werden verfügen basiert, wird Ihre gesamte zweite Abfrage auch neu kompiliert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-547">Following the same example as above, if you have a second query that relies on a query that needs to be recompiled, your entire second query will also be recompiled.</span></span> <span data-ttu-id="6cfbd-548">Hier ist ein Beispiel zur Veranschaulichung dieses Szenario:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-548">Here’s an example to illustrate this scenario:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

<span data-ttu-id="6cfbd-549">Im Beispiel ist generisch, aber es wird veranschaulicht, wie Verknüpfen mit FirstQuery SecondQuery nicht zwischengespeichert, abrufen können verursacht werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-549">The example is generic, but it illustrates how linking to firstQuery is causing secondQuery to be unable to get cached.</span></span> <span data-ttu-id="6cfbd-550">Wenn FirstQuery nicht mit einer Abfrage, die erforderlich sind hätte, neu kompilieren zu müssen, würde klicken Sie dann SecondQuery zwischengespeichert wurden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-550">If firstQuery had not been a query that requires recompiling, then secondQuery would have been cached.</span></span>

## <a name="5-notracking-queries"></a><span data-ttu-id="6cfbd-551">5 NoTracking-Abfragen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-551">5 NoTracking Queries</span></span>

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a><span data-ttu-id="6cfbd-552">5.1 Deaktivieren der änderungsnachverfolgung um Status-Verwaltungsaufwand zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-552">5.1 Disabling change tracking to reduce state management overhead</span></span>

<span data-ttu-id="6cfbd-553">Wenn Sie in einem Szenario mit nur-Lese und den Aufwand für das Laden die Objekte in ObjectStateManager vermeiden möchten, können Sie Abfragen "ohne nachverfolgung" ausgeben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-553">If you are in a read-only scenario and want to avoid the overhead of loading the objects into the ObjectStateManager, you can issue "No Tracking" queries.</span></span>  <span data-ttu-id="6cfbd-554">Die änderungsnachverfolgung kann auch auf Abfrageebene deaktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-554">Change tracking can be disabled at the query level.</span></span>

<span data-ttu-id="6cfbd-555">Beachten Sie jedoch, dass durch das Deaktivieren der änderungsnachverfolgung Sie effektiv aus dem Objektcache eingeschaltet sind.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-555">Note though that by disabling change tracking you are effectively turning off the object cache.</span></span> <span data-ttu-id="6cfbd-556">Beim Abfragen einer Entität können wir Materialisierung nicht überspringen, indem zuvor materialisierte Abfrageergebnisse aus dem ObjectStateManager abgerufen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-556">When you query for an entity, we can't skip materialization by pulling the previously-materialized query results from the ObjectStateManager.</span></span> <span data-ttu-id="6cfbd-557">Wenn Sie wiederholt die gleichen Entitäten im gleichen Kontext Abfragen sind, möglicherweise tatsächlich eine Leistung profitieren, Aktivieren der änderungsnachverfolgung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-557">If you are repeatedly querying for the same entities on the same context, you might actually see a performance benefit from enabling change tracking.</span></span>

<span data-ttu-id="6cfbd-558">Bei der Verwendung von ObjectContext Abfrage speichert ObjectQuery- und "ObjectSet"-Instanzen eine MergeOption, nachdem sie festgelegt ist, und Abfragen, die darauf bestehen, die effektive MergeOption von der übergeordneten Abfrage übernimmt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-558">When querying using ObjectContext, ObjectQuery and ObjectSet instances will remember a MergeOption once it is set, and queries that are composed on them will inherit the effective MergeOption of the parent query.</span></span> <span data-ttu-id="6cfbd-559">Wenn "DbContext" verwenden, kann die Überwachung durch Aufrufen des AsNoTracking()-Modifizierers auf "DbSet" deaktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-559">When using DbContext, tracking can be disabled by calling the AsNoTracking() modifier on the DbSet.</span></span>

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a><span data-ttu-id="6cfbd-560">5.1.1 Deaktivieren der änderungsnachverfolgung für eine Abfrage, bei Verwendung von "DbContext"</span><span class="sxs-lookup"><span data-stu-id="6cfbd-560">5.1.1 Disabling change tracking for a query when using DbContext</span></span>

<span data-ttu-id="6cfbd-561">Sie können den Modus einer Abfrage zu NoTracking wechseln, durch einen Aufruf an die AsNoTracking()-Methode in der Abfrage zu verketten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-561">You can switch the mode of a query to NoTracking by chaining a call to the AsNoTracking() method in the query.</span></span> <span data-ttu-id="6cfbd-562">Im Gegensatz zu ObjectQuery verfügen nicht die "DbSet" und DbQuery Klassen in der DbContext-API eine änderbare Eigenschaft für die MergeOption.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-562">Unlike ObjectQuery, the DbSet and DbQuery classes in the DbContext API don’t have a mutable property for the MergeOption.</span></span>

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a><span data-ttu-id="6cfbd-563">5.1.2 Deaktivieren der änderungsnachverfolgung auf Abfrageebene mithilfe von ObjectContext</span><span class="sxs-lookup"><span data-stu-id="6cfbd-563">5.1.2 Disabling change tracking at the query level using ObjectContext</span></span>

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a><span data-ttu-id="6cfbd-564">5.1.3 Deaktivieren der änderungsnachverfolgung für eine gesamte Entität, die mit ObjectContext festgelegt</span><span class="sxs-lookup"><span data-stu-id="6cfbd-564">5.1.3 Disabling change tracking for an entire entity set using ObjectContext</span></span>

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52-test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a><span data-ttu-id="6cfbd-565">5.2 Testmetriken Sie veranschaulicht die Leistungsvorteile bei NoTracking-Abfragen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-565">5.2 Test Metrics demonstrating the performance benefit of NoTracking queries</span></span>

<span data-ttu-id="6cfbd-566">In diesem Test suchen wir auf Kosten der ObjectStateManager durch Vergleichen der NoTracking-Abfragen für das Modell Navision Überwachung ausfüllen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-566">In this test we look at the cost of filling the ObjectStateManager by comparing Tracking to NoTracking queries for the Navision model.</span></span> <span data-ttu-id="6cfbd-567">Finden Sie im Anhang eine Beschreibung des Modells Navision und die Typen von Abfragen, die ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-567">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="6cfbd-568">In diesem Test haben wir die Liste der Abfragen durchlaufen und jeweils einmal ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-568">In this test, we iterate through the list of queries and execute each one once.</span></span> <span data-ttu-id="6cfbd-569">Wir haben zwei Varianten der Testassembly, einmal mit der NoTracking-Abfragen und einmal mit der standardmäßigen Zusammenführungsoption von "AppendOnly" ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-569">We ran two variations of the test, once with NoTracking queries and once with the default merge option of "AppendOnly".</span></span> <span data-ttu-id="6cfbd-570">Wir haben jede Variante 3 Mal und nutzen den Mittelwert des ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-570">We ran each variation 3 times and take the mean value of the runs.</span></span> <span data-ttu-id="6cfbd-571">Zwischen den Tests haben wir den Abfragecache auf dem SQL Server löschen, und Verkleinern die Tempdb, indem Sie die folgenden Befehle ausführen:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-571">Between the tests we clear the query cache on the SQL Server and shrink the tempdb by running the following commands:</span></span>

1.  <span data-ttu-id="6cfbd-572">DBCC DROPCLEANBUFFERS</span><span class="sxs-lookup"><span data-stu-id="6cfbd-572">DBCC DROPCLEANBUFFERS</span></span>
2.  <span data-ttu-id="6cfbd-573">DBCC FREEPROCCACHE</span><span class="sxs-lookup"><span data-stu-id="6cfbd-573">DBCC FREEPROCCACHE</span></span>
3.  <span data-ttu-id="6cfbd-574">DBCC SHRINKDATABASE (Tempdb, 0)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-574">DBCC SHRINKDATABASE (tempdb, 0)</span></span>

<span data-ttu-id="6cfbd-575">Testergebnisse, Median mehr als 3 ausgeführt wird:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-575">Test Results, median over 3 runs:</span></span>

|                        | <span data-ttu-id="6cfbd-576">KEINE NACHVERFOLGUNG – ARBEITSSATZ</span><span class="sxs-lookup"><span data-stu-id="6cfbd-576">NO TRACKING – WORKING SET</span></span> | <span data-ttu-id="6cfbd-577">KEINE NACHVERFOLGUNG – ZEIT</span><span class="sxs-lookup"><span data-stu-id="6cfbd-577">NO TRACKING – TIME</span></span> | <span data-ttu-id="6cfbd-578">NUR-ANHÄNGEN SIE-SATZ ARBEITEN</span><span class="sxs-lookup"><span data-stu-id="6cfbd-578">APPEND ONLY – WORKING SET</span></span> | <span data-ttu-id="6cfbd-579">FÜGEN SIE NUR – ZEIT</span><span class="sxs-lookup"><span data-stu-id="6cfbd-579">APPEND ONLY – TIME</span></span> |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| <span data-ttu-id="6cfbd-580">**Entitätsframework 5**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-580">**Entity Framework 5**</span></span> | <span data-ttu-id="6cfbd-581">460361728</span><span class="sxs-lookup"><span data-stu-id="6cfbd-581">460361728</span></span>                 | <span data-ttu-id="6cfbd-582">1163536 ms</span><span class="sxs-lookup"><span data-stu-id="6cfbd-582">1163536 ms</span></span>         | <span data-ttu-id="6cfbd-583">596545536</span><span class="sxs-lookup"><span data-stu-id="6cfbd-583">596545536</span></span>                 | <span data-ttu-id="6cfbd-584">1273042 ms</span><span class="sxs-lookup"><span data-stu-id="6cfbd-584">1273042 ms</span></span>         |
| <span data-ttu-id="6cfbd-585">**Entity Framework 6**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-585">**Entity Framework 6**</span></span> | <span data-ttu-id="6cfbd-586">647127040</span><span class="sxs-lookup"><span data-stu-id="6cfbd-586">647127040</span></span>                 | <span data-ttu-id="6cfbd-587">190228 ms</span><span class="sxs-lookup"><span data-stu-id="6cfbd-587">190228 ms</span></span>          | <span data-ttu-id="6cfbd-588">832798720</span><span class="sxs-lookup"><span data-stu-id="6cfbd-588">832798720</span></span>                 | <span data-ttu-id="6cfbd-589">195521 ms</span><span class="sxs-lookup"><span data-stu-id="6cfbd-589">195521 ms</span></span>          |

<span data-ttu-id="6cfbd-590">Entitätsframework 5 müssen einen geringeren Speicherbedarf am Ende der Ausführung als Entity Framework 6 ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-590">Entity Framework 5 will have a smaller memory footprint at the end of the run than Entity Framework 6 does.</span></span> <span data-ttu-id="6cfbd-591">Zusätzliche durch Entity Framework 6 belegte Arbeitsspeicher ist das Ergebnis zusätzlichen Arbeitsspeicher-Strukturen und Code, der neuen Features und eine bessere Leistung zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-591">The additional memory consumed by Entity Framework 6 is the result of additional memory structures and code that enable new features and better performance.</span></span>

<span data-ttu-id="6cfbd-592">Es gibt auch ein klaren Unterschied im Speicherbedarf bei Verwendung von ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-592">There’s also a clear difference in memory footprint when using the ObjectStateManager.</span></span> <span data-ttu-id="6cfbd-593">Entitätsframework 5 erhöht, was den Speicherbedarf von 30 %, wenn nachverfolgt alle Entitäten, die wir aus der Datenbank materialisiert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-593">Entity Framework 5 increased its footprint by 30% when keeping track of all the entities we materialized from the database.</span></span> <span data-ttu-id="6cfbd-594">Entitätsframework 6 erhöht, was den Speicherbedarf von 28 %, dabei.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-594">Entity Framework 6 increased its footprint by 28% when doing so.</span></span>

<span data-ttu-id="6cfbd-595">Im Hinblick auf die Zeit übertrifft Entity Framework 6 Entity Framework 5 in diesem Test durch eine große Rand an.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-595">In terms of time, Entity Framework 6 outperforms Entity Framework 5 in this test by a large margin.</span></span> <span data-ttu-id="6cfbd-596">Entitätsframework 6 abgeschlossen, den Test in ungefähr 16 % der Zeit von Entity Framework 5 genutzt wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-596">Entity Framework 6 completed the test in roughly 16% of the time consumed by Entity Framework 5.</span></span> <span data-ttu-id="6cfbd-597">Darüber hinaus wird Entity Framework 5 9 % mehr Zeit, wenn der ObjectStateManager verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-597">Additionally, Entity Framework 5 takes 9% more time to complete when the ObjectStateManager is being used.</span></span> <span data-ttu-id="6cfbd-598">Im Gegensatz dazu wird Entity Framework 6 3 % mehr Zeit, wenn mithilfe von ObjectStateManager verwendet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-598">In comparison, Entity Framework 6 is using 3% more time when using the ObjectStateManager.</span></span>

## <a name="6-query-execution-options"></a><span data-ttu-id="6cfbd-599">6 Abfrageausführungsoptionen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-599">6 Query Execution Options</span></span>

<span data-ttu-id="6cfbd-600">Entitätsframework bietet verschiedene Möglichkeiten, die Abfrage.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-600">Entity Framework offers several different ways to query.</span></span> <span data-ttu-id="6cfbd-601">Wir sehen Sie sich die folgenden Optionen, vergleichen Sie die vor- und Nachteile der einzelnen und untersuchen Sie ihre Leistungsmerkmale:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-601">We'll take a look at the following options, compare the pros and cons of each, and examine their performance characteristics:</span></span>

-   <span data-ttu-id="6cfbd-602">LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-602">LINQ to Entities.</span></span>
-   <span data-ttu-id="6cfbd-603">Keine nachverfolgung LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-603">No Tracking LINQ to Entities.</span></span>
-   <span data-ttu-id="6cfbd-604">Entity SQL über eine ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-604">Entity SQL over an ObjectQuery.</span></span>
-   <span data-ttu-id="6cfbd-605">Entity SQL über eine von "EntityCommand".</span><span class="sxs-lookup"><span data-stu-id="6cfbd-605">Entity SQL over an EntityCommand.</span></span>
-   <span data-ttu-id="6cfbd-606">"ExecuteStoreQuery".</span><span class="sxs-lookup"><span data-stu-id="6cfbd-606">ExecuteStoreQuery.</span></span>
-   <span data-ttu-id="6cfbd-607">SqlQuery.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-607">SqlQuery.</span></span>
-   <span data-ttu-id="6cfbd-608">CompiledQuery.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-608">CompiledQuery.</span></span>

### <a name="61-------linq-to-entities-queries"></a><span data-ttu-id="6cfbd-609">6.1-LINQ to Entities-Abfragen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-609">6.1       LINQ to Entities queries</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="6cfbd-610">**Experten**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-610">**Pros**</span></span>

-   <span data-ttu-id="6cfbd-611">Geeignet für CRUD-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-611">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="6cfbd-612">Vollständig materialisierte Objekte.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-612">Fully materialized objects.</span></span>
-   <span data-ttu-id="6cfbd-613">Am einfachsten, mit der Syntax schreiben, die in der Programmiersprache integriert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-613">Simplest to write with syntax built into the programming language.</span></span>
-   <span data-ttu-id="6cfbd-614">Gute Leistung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-614">Good performance.</span></span>

<span data-ttu-id="6cfbd-615">**Nachteile**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-615">**Cons**</span></span>

-   <span data-ttu-id="6cfbd-616">Bestimmte technische Einschränkungen, z. B.:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-616">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="6cfbd-617">Muster DefaultIfEmpty für OUTER JOIN-Abfragen mit komplexer Abfragen als einfache OUTER JOIN-Anweisungen in Entity SQL führen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-617">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="6cfbd-618">Sie können nicht weiterhin verwenden wie die entsprechende allgemeine Muster.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-618">You still can’t use LIKE with general pattern matching.</span></span>

### <a name="62-------no-tracking-linq-to-entities-queries"></a><span data-ttu-id="6cfbd-619">6.2 keine nachverfolgung LINQ to Entities-Abfragen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-619">6.2       No Tracking LINQ to Entities queries</span></span>

<span data-ttu-id="6cfbd-620">Wenn der Kontext ObjectContext abgeleitet:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-620">When the context derives ObjectContext:</span></span>

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="6cfbd-621">Wenn der Kontext für "DbContext" abgeleitet:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-621">When the context derives DbContext:</span></span>

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="6cfbd-622">**Experten**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-622">**Pros**</span></span>

-   <span data-ttu-id="6cfbd-623">Verbesserte Leistung gegenüber regulären LINQ-Abfragen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-623">Improved performance over regular LINQ queries.</span></span>
-   <span data-ttu-id="6cfbd-624">Vollständig materialisierte Objekte.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-624">Fully materialized objects.</span></span>
-   <span data-ttu-id="6cfbd-625">Am einfachsten, mit der Syntax schreiben, die in der Programmiersprache integriert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-625">Simplest to write with syntax built into the programming language.</span></span>

<span data-ttu-id="6cfbd-626">**Nachteile**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-626">**Cons**</span></span>

-   <span data-ttu-id="6cfbd-627">Nicht geeignet für CRUD-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-627">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="6cfbd-628">Bestimmte technische Einschränkungen, z. B.:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-628">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="6cfbd-629">Muster DefaultIfEmpty für OUTER JOIN-Abfragen mit komplexer Abfragen als einfache OUTER JOIN-Anweisungen in Entity SQL führen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-629">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="6cfbd-630">Sie können nicht weiterhin verwenden wie die entsprechende allgemeine Muster.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-630">You still can’t use LIKE with general pattern matching.</span></span>

<span data-ttu-id="6cfbd-631">Beachten Sie, dass Abfragen, die skalare Eigenschaften zu projizieren nicht nachverfolgt werden, auch wenn der NoTracking nicht angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-631">Note that queries that project scalar properties are not tracked even if the NoTracking is not specified.</span></span> <span data-ttu-id="6cfbd-632">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-632">For example:</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

<span data-ttu-id="6cfbd-633">Diese Abfrage nicht explizit angeben, wird der NoTracking, aber da es nicht materialisieren ist ein Typ, der dem Objekt-Status-Manager klicken Sie dann das materialisierte Ergebnis bekannt sind nicht nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-633">This particular query doesn’t explicitly specify being NoTracking, but since it’s not materializing a type that’s known to the object state manager then the materialized result is not tracked.</span></span>

### <a name="63-------entity-sql-over-an-objectquery"></a><span data-ttu-id="6cfbd-634">6.3 Entity SQL über eine ObjectQuery</span><span class="sxs-lookup"><span data-stu-id="6cfbd-634">6.3       Entity SQL over an ObjectQuery</span></span>

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

<span data-ttu-id="6cfbd-635">**Experten**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-635">**Pros**</span></span>

-   <span data-ttu-id="6cfbd-636">Geeignet für CRUD-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-636">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="6cfbd-637">Vollständig materialisierte Objekte.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-637">Fully materialized objects.</span></span>
-   <span data-ttu-id="6cfbd-638">Unterstützt das Abfragen Zwischenspeichern von Abfrageplänen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-638">Supports query plan caching.</span></span>

<span data-ttu-id="6cfbd-639">**Nachteile**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-639">**Cons**</span></span>

-   <span data-ttu-id="6cfbd-640">Umfasst Text Abfragezeichenfolgen sind anfälliger für Fehler als Abfragekonstrukte integriert die Sprache an.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-640">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>

### <a name="64-------entity-sql-over-an-entity-command"></a><span data-ttu-id="6cfbd-641">6.4 Entity SQL über eine Entität-Befehl</span><span class="sxs-lookup"><span data-stu-id="6cfbd-641">6.4       Entity SQL over an Entity Command</span></span>

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

<span data-ttu-id="6cfbd-642">**Experten**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-642">**Pros**</span></span>

-   <span data-ttu-id="6cfbd-643">Unterstützt das Abfragen Zwischenspeichern von Abfrageplänen in .NET 4.0 (Zwischenspeichern von Abfrageplänen wird von allen anderen Abfragetypen in .NET 4.5 unterstützt).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-643">Supports query plan caching in .NET 4.0 (plan caching is supported by all other query types in .NET 4.5).</span></span>

<span data-ttu-id="6cfbd-644">**Nachteile**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-644">**Cons**</span></span>

-   <span data-ttu-id="6cfbd-645">Umfasst Text Abfragezeichenfolgen sind anfälliger für Fehler als Abfragekonstrukte integriert die Sprache an.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-645">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>
-   <span data-ttu-id="6cfbd-646">Nicht geeignet für CRUD-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-646">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="6cfbd-647">Ergebnisse werden nicht automatisch materialisiert, und müssen aus der Datenleser gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-647">Results are not automatically materialized, and must be read from the data reader.</span></span>

### <a name="65-------sqlquery-and-executestorequery"></a><span data-ttu-id="6cfbd-648">6.5 SqlQuery und "ExecuteStoreQuery"</span><span class="sxs-lookup"><span data-stu-id="6cfbd-648">6.5       SqlQuery and ExecuteStoreQuery</span></span>

<span data-ttu-id="6cfbd-649">SqlQuery für Datenbank:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-649">SqlQuery on Database:</span></span>

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

<span data-ttu-id="6cfbd-650">SqlQuery auf "DbSet":</span><span class="sxs-lookup"><span data-stu-id="6cfbd-650">SqlQuery on DbSet:</span></span>

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

<span data-ttu-id="6cfbd-651">ExecyteStoreQuery:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-651">ExecyteStoreQuery:</span></span>

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

<span data-ttu-id="6cfbd-652">**Experten**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-652">**Pros**</span></span>

-   <span data-ttu-id="6cfbd-653">Im Allgemeinen schnellste Leistung, da Plan Compiler umgangen wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-653">Generally fastest performance since plan compiler is bypassed.</span></span>
-   <span data-ttu-id="6cfbd-654">Vollständig materialisierte Objekte.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-654">Fully materialized objects.</span></span>
-   <span data-ttu-id="6cfbd-655">Geeignet für CRUD-Vorgänge bei der Verwendung von "DbSet".</span><span class="sxs-lookup"><span data-stu-id="6cfbd-655">Suitable for CUD operations when used from the DbSet.</span></span>

<span data-ttu-id="6cfbd-656">**Nachteile**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-656">**Cons**</span></span>

-   <span data-ttu-id="6cfbd-657">Abfrage ist und fehleranfällig.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-657">Query is textual and error prone.</span></span>
-   <span data-ttu-id="6cfbd-658">Abfrage wird an einen bestimmten Back-End mit Speicher-Semantik statt konzeptionelle Semantik gebunden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-658">Query is tied to a specific backend by using store semantics instead of conceptual semantics.</span></span>
-   <span data-ttu-id="6cfbd-659">Bei der Vererbung vorhanden ist, muss Handgefertigte Abfrage zuordnungsbedingungen für den angeforderten Typ zu berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-659">When inheritance is present, handcrafted query needs to account for mapping conditions for the type requested.</span></span>

### <a name="66-------compiledquery"></a><span data-ttu-id="6cfbd-660">6.6 CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="6cfbd-660">6.6       CompiledQuery</span></span>

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

<span data-ttu-id="6cfbd-661">**Experten**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-661">**Pros**</span></span>

-   <span data-ttu-id="6cfbd-662">Stellt ein 7 % leistungsverbesserung von bis zu über reguläre LINQ-Abfragen bereit.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-662">Provides up to a 7% performance improvement over regular LINQ queries.</span></span>
-   <span data-ttu-id="6cfbd-663">Vollständig materialisierte Objekte.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-663">Fully materialized objects.</span></span>
-   <span data-ttu-id="6cfbd-664">Geeignet für CRUD-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-664">Suitable for CUD operations.</span></span>

<span data-ttu-id="6cfbd-665">**Nachteile**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-665">**Cons**</span></span>

-   <span data-ttu-id="6cfbd-666">Erhöhte Komplexität und Aufwand zu programmieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-666">Increased complexity and programming overhead.</span></span>
-   <span data-ttu-id="6cfbd-667">Verbesserung der Leistung geht verloren, wenn zusätzlich eine kompilierte Abfrage zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-667">The performance improvement is lost when composing on top of a compiled query.</span></span>
-   <span data-ttu-id="6cfbd-668">Einige LINQ-Abfragen können nicht als eine CompiledQuery - z. B. Projektionen von anonymen Typen geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-668">Some LINQ queries can't be written as a CompiledQuery - for example, projections of anonymous types.</span></span>

### <a name="67-------performance-comparison-of-different-query-options"></a><span data-ttu-id="6cfbd-669">6.7 Leistungsvergleich der anderen Abfrageoptionen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-669">6.7       Performance Comparison of different query options</span></span>

<span data-ttu-id="6cfbd-670">Einfache, in denen die kontexterstellung kein Timeout aufgetreten war, Microbenchmarks wurden in der Praxis testen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-670">Simple microbenchmarks where the context creation was not timed were put to the test.</span></span> <span data-ttu-id="6cfbd-671">Wir Maßen 5000 Mal für einen Satz von Entitäten nicht zwischengespeicherten, in einer kontrollierten Umgebung Abfragen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-671">We measured querying 5000 times for a set of non-cached entities in a controlled environment.</span></span> <span data-ttu-id="6cfbd-672">Diese Zahlen sind, die mit einer Warnung ausgeführt werden: sie spiegeln nicht die tatsächlichen Werte, die von einer Anwendung erstellt, aber stattdessen sind sie ein sehr genau Maß wie viel Leistung Unterschied beim Vergleich von verschiedenen Abfragen-Optionen besteht Äpfel mit Äpfeln, ausgenommen die Kosten für die ein neuen Kontext erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-672">These numbers are to be taken with a warning: they do not reflect actual numbers produced by an application, but instead they are a very accurate measurement of how much of a performance difference there is when different querying options are compared apples-to-apples, excluding the cost of creating a new context.</span></span>

| <span data-ttu-id="6cfbd-673">EF</span><span class="sxs-lookup"><span data-stu-id="6cfbd-673">EF</span></span>  | <span data-ttu-id="6cfbd-674">Test</span><span class="sxs-lookup"><span data-stu-id="6cfbd-674">Test</span></span>                                 | <span data-ttu-id="6cfbd-675">Zeit (ms)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-675">Time (ms)</span></span> | <span data-ttu-id="6cfbd-676">Arbeitsspeicher</span><span class="sxs-lookup"><span data-stu-id="6cfbd-676">Memory</span></span>   |
|:----|:-------------------------------------|:----------|:---------|
| <span data-ttu-id="6cfbd-677">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-677">EF5</span></span> | <span data-ttu-id="6cfbd-678">ObjectContext ESQL</span><span class="sxs-lookup"><span data-stu-id="6cfbd-678">ObjectContext ESQL</span></span>                   | <span data-ttu-id="6cfbd-679">2414</span><span class="sxs-lookup"><span data-stu-id="6cfbd-679">2414</span></span>      | <span data-ttu-id="6cfbd-680">38801408</span><span class="sxs-lookup"><span data-stu-id="6cfbd-680">38801408</span></span> |
| <span data-ttu-id="6cfbd-681">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-681">EF5</span></span> | <span data-ttu-id="6cfbd-682">ObjectContext Linq-Abfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-682">ObjectContext Linq Query</span></span>             | <span data-ttu-id="6cfbd-683">2692</span><span class="sxs-lookup"><span data-stu-id="6cfbd-683">2692</span></span>      | <span data-ttu-id="6cfbd-684">38277120</span><span class="sxs-lookup"><span data-stu-id="6cfbd-684">38277120</span></span> |
| <span data-ttu-id="6cfbd-685">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-685">EF5</span></span> | <span data-ttu-id="6cfbd-686">"DbContext" Linq-Abfrage keine nachverfolgung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-686">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="6cfbd-687">2818</span><span class="sxs-lookup"><span data-stu-id="6cfbd-687">2818</span></span>      | <span data-ttu-id="6cfbd-688">41840640</span><span class="sxs-lookup"><span data-stu-id="6cfbd-688">41840640</span></span> |
| <span data-ttu-id="6cfbd-689">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-689">EF5</span></span> | <span data-ttu-id="6cfbd-690">Linq-Abfrage für "DbContext"</span><span class="sxs-lookup"><span data-stu-id="6cfbd-690">DbContext Linq Query</span></span>                 | <span data-ttu-id="6cfbd-691">2930</span><span class="sxs-lookup"><span data-stu-id="6cfbd-691">2930</span></span>      | <span data-ttu-id="6cfbd-692">41771008</span><span class="sxs-lookup"><span data-stu-id="6cfbd-692">41771008</span></span> |
| <span data-ttu-id="6cfbd-693">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-693">EF5</span></span> | <span data-ttu-id="6cfbd-694">Keine nachverfolgung der ObjectContext-Linq-Abfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-694">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="6cfbd-695">3013</span><span class="sxs-lookup"><span data-stu-id="6cfbd-695">3013</span></span>      | <span data-ttu-id="6cfbd-696">38412288</span><span class="sxs-lookup"><span data-stu-id="6cfbd-696">38412288</span></span> |
|     |                                      |           |          |
| <span data-ttu-id="6cfbd-697">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-697">EF6</span></span> | <span data-ttu-id="6cfbd-698">ObjectContext ESQL</span><span class="sxs-lookup"><span data-stu-id="6cfbd-698">ObjectContext ESQL</span></span>                   | <span data-ttu-id="6cfbd-699">2059</span><span class="sxs-lookup"><span data-stu-id="6cfbd-699">2059</span></span>      | <span data-ttu-id="6cfbd-700">46039040</span><span class="sxs-lookup"><span data-stu-id="6cfbd-700">46039040</span></span> |
| <span data-ttu-id="6cfbd-701">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-701">EF6</span></span> | <span data-ttu-id="6cfbd-702">ObjectContext Linq-Abfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-702">ObjectContext Linq Query</span></span>             | <span data-ttu-id="6cfbd-703">3074</span><span class="sxs-lookup"><span data-stu-id="6cfbd-703">3074</span></span>      | <span data-ttu-id="6cfbd-704">45248512</span><span class="sxs-lookup"><span data-stu-id="6cfbd-704">45248512</span></span> |
| <span data-ttu-id="6cfbd-705">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-705">EF6</span></span> | <span data-ttu-id="6cfbd-706">"DbContext" Linq-Abfrage keine nachverfolgung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-706">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="6cfbd-707">3125</span><span class="sxs-lookup"><span data-stu-id="6cfbd-707">3125</span></span>      | <span data-ttu-id="6cfbd-708">47575040</span><span class="sxs-lookup"><span data-stu-id="6cfbd-708">47575040</span></span> |
| <span data-ttu-id="6cfbd-709">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-709">EF6</span></span> | <span data-ttu-id="6cfbd-710">Linq-Abfrage für "DbContext"</span><span class="sxs-lookup"><span data-stu-id="6cfbd-710">DbContext Linq Query</span></span>                 | <span data-ttu-id="6cfbd-711">3420</span><span class="sxs-lookup"><span data-stu-id="6cfbd-711">3420</span></span>      | <span data-ttu-id="6cfbd-712">47652864</span><span class="sxs-lookup"><span data-stu-id="6cfbd-712">47652864</span></span> |
| <span data-ttu-id="6cfbd-713">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-713">EF6</span></span> | <span data-ttu-id="6cfbd-714">Keine nachverfolgung der ObjectContext-Linq-Abfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-714">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="6cfbd-715">3593</span><span class="sxs-lookup"><span data-stu-id="6cfbd-715">3593</span></span>      | <span data-ttu-id="6cfbd-716">45260800</span><span class="sxs-lookup"><span data-stu-id="6cfbd-716">45260800</span></span> |

![EF5 micro-Benchmarks, 5000 betriebsbereiten Iterationen](~/ef6/media/ef5micro5000warm.png)

![EF6-micro-Benchmarks, 5000 betriebsbereiten Iterationen](~/ef6/media/ef6micro5000warm.png)

<span data-ttu-id="6cfbd-719">Microbenchmarks sind sehr empfindlich gegenüber kleinen Änderungen im Code.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-719">Microbenchmarks are very sensitive to small changes in the code.</span></span> <span data-ttu-id="6cfbd-720">In diesem Fall unterscheiden sich die Kosten für die Entity Framework 5 und Entity Framework 6 sind, auf das Hinzufügen von [Abfangfunktion](~/ef6/fundamentals/logging-and-interception.md) und [transaktionale Verbesserungen](~/ef6/saving/transactions.md).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-720">In this case, the difference between the costs of Entity Framework 5 and Entity Framework 6 are due to the addition of [interception](~/ef6/fundamentals/logging-and-interception.md) and [transactional improvements](~/ef6/saving/transactions.md).</span></span> <span data-ttu-id="6cfbd-721">Diese Zahlen Microbenchmarks sind jedoch einen verstärkten Visionen in einem sehr kleinen informationsfragment der Funktionsweise von Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-721">These microbenchmarks numbers, however, are an amplified vision into a very small fragment of what Entity Framework does.</span></span> <span data-ttu-id="6cfbd-722">Reale Szenarien betriebsbereiten Abfragen sollte einem Leistungsverlust nicht angezeigt werden, beim Aktualisieren von Entity Framework 5 auf Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-722">Real-world scenarios of warm queries should not see a performance regression when upgrading from Entity Framework 5 to Entity Framework 6.</span></span>

<span data-ttu-id="6cfbd-723">Um die reale Leistung der anderen Abfrageoptionen vergleichen zu können, haben wir 5 separaten Variationen, in dem wir eine andere Abfrage-Option verwenden, um alle Produkte auswählen, deren Kategoriename "Getränke" wird, erstellt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-723">To compare the real-world performance of the different query options, we created 5 separate test variations where we use a different query option to select all products whose category name is "Beverages".</span></span> <span data-ttu-id="6cfbd-724">Jede Iteration umfasst die Kosten für die Erstellung von Kontext und die Kosten für die Umsetzung von Entitäten in alle zurückgegebenen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-724">Each iteration includes the cost of creating the context, and the cost of materializing all returned entities.</span></span> <span data-ttu-id="6cfbd-725">Bevor Sie die Summe der Timeout bei 1000 Iterationen zu können, werden 10 Iterationen untimed ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-725">10 iterations are run untimed before taking the sum of 1000 timed iterations.</span></span> <span data-ttu-id="6cfbd-726">Die angezeigten Ergebnisse sind die durchschnittliche Ausführung 5 ausgeführt wird, der einzelnen Tests entnommen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-726">The results shown are the median run taken from 5 runs of each test.</span></span> <span data-ttu-id="6cfbd-727">Weitere Informationen finden Sie in Anhang B, die den Code für den Test enthält.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-727">For more information, see Appendix B which includes the code for the test.</span></span>

| <span data-ttu-id="6cfbd-728">EF</span><span class="sxs-lookup"><span data-stu-id="6cfbd-728">EF</span></span>  | <span data-ttu-id="6cfbd-729">Test</span><span class="sxs-lookup"><span data-stu-id="6cfbd-729">Test</span></span>                                        | <span data-ttu-id="6cfbd-730">Zeit (ms)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-730">Time (ms)</span></span> | <span data-ttu-id="6cfbd-731">Arbeitsspeicher</span><span class="sxs-lookup"><span data-stu-id="6cfbd-731">Memory</span></span>   |
|:----|:--------------------------------------------|:----------|:---------|
| <span data-ttu-id="6cfbd-732">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-732">EF5</span></span> | <span data-ttu-id="6cfbd-733">ObjectContext-Entity-Befehl</span><span class="sxs-lookup"><span data-stu-id="6cfbd-733">ObjectContext Entity Command</span></span>                | <span data-ttu-id="6cfbd-734">621</span><span class="sxs-lookup"><span data-stu-id="6cfbd-734">621</span></span>       | <span data-ttu-id="6cfbd-735">39350272</span><span class="sxs-lookup"><span data-stu-id="6cfbd-735">39350272</span></span> |
| <span data-ttu-id="6cfbd-736">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-736">EF5</span></span> | <span data-ttu-id="6cfbd-737">Sql-Abfrage für "DbContext" für Datenbank</span><span class="sxs-lookup"><span data-stu-id="6cfbd-737">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="6cfbd-738">825</span><span class="sxs-lookup"><span data-stu-id="6cfbd-738">825</span></span>       | <span data-ttu-id="6cfbd-739">37519360</span><span class="sxs-lookup"><span data-stu-id="6cfbd-739">37519360</span></span> |
| <span data-ttu-id="6cfbd-740">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-740">EF5</span></span> | <span data-ttu-id="6cfbd-741">ObjectContext-Store-Abfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-741">ObjectContext Store Query</span></span>                   | <span data-ttu-id="6cfbd-742">878</span><span class="sxs-lookup"><span data-stu-id="6cfbd-742">878</span></span>       | <span data-ttu-id="6cfbd-743">39460864</span><span class="sxs-lookup"><span data-stu-id="6cfbd-743">39460864</span></span> |
| <span data-ttu-id="6cfbd-744">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-744">EF5</span></span> | <span data-ttu-id="6cfbd-745">Keine nachverfolgung der ObjectContext-Linq-Abfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-745">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="6cfbd-746">969</span><span class="sxs-lookup"><span data-stu-id="6cfbd-746">969</span></span>       | <span data-ttu-id="6cfbd-747">38293504</span><span class="sxs-lookup"><span data-stu-id="6cfbd-747">38293504</span></span> |
| <span data-ttu-id="6cfbd-748">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-748">EF5</span></span> | <span data-ttu-id="6cfbd-749">ObjectContext Entity Sql mit Objektabfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-749">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="6cfbd-750">1089</span><span class="sxs-lookup"><span data-stu-id="6cfbd-750">1089</span></span>      | <span data-ttu-id="6cfbd-751">38981632</span><span class="sxs-lookup"><span data-stu-id="6cfbd-751">38981632</span></span> |
| <span data-ttu-id="6cfbd-752">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-752">EF5</span></span> | <span data-ttu-id="6cfbd-753">Kompilierte Abfrage ObjectContext</span><span class="sxs-lookup"><span data-stu-id="6cfbd-753">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="6cfbd-754">1099</span><span class="sxs-lookup"><span data-stu-id="6cfbd-754">1099</span></span>      | <span data-ttu-id="6cfbd-755">38682624</span><span class="sxs-lookup"><span data-stu-id="6cfbd-755">38682624</span></span> |
| <span data-ttu-id="6cfbd-756">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-756">EF5</span></span> | <span data-ttu-id="6cfbd-757">ObjectContext Linq-Abfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-757">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="6cfbd-758">1152</span><span class="sxs-lookup"><span data-stu-id="6cfbd-758">1152</span></span>      | <span data-ttu-id="6cfbd-759">38178816</span><span class="sxs-lookup"><span data-stu-id="6cfbd-759">38178816</span></span> |
| <span data-ttu-id="6cfbd-760">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-760">EF5</span></span> | <span data-ttu-id="6cfbd-761">"DbContext" Linq-Abfrage keine nachverfolgung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-761">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="6cfbd-762">1208</span><span class="sxs-lookup"><span data-stu-id="6cfbd-762">1208</span></span>      | <span data-ttu-id="6cfbd-763">41803776</span><span class="sxs-lookup"><span data-stu-id="6cfbd-763">41803776</span></span> |
| <span data-ttu-id="6cfbd-764">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-764">EF5</span></span> | <span data-ttu-id="6cfbd-765">Sql-Abfrage für "DbContext" auf "DbSet"</span><span class="sxs-lookup"><span data-stu-id="6cfbd-765">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="6cfbd-766">1414</span><span class="sxs-lookup"><span data-stu-id="6cfbd-766">1414</span></span>      | <span data-ttu-id="6cfbd-767">37982208</span><span class="sxs-lookup"><span data-stu-id="6cfbd-767">37982208</span></span> |
| <span data-ttu-id="6cfbd-768">EF5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-768">EF5</span></span> | <span data-ttu-id="6cfbd-769">Linq-Abfrage für "DbContext"</span><span class="sxs-lookup"><span data-stu-id="6cfbd-769">DbContext Linq Query</span></span>                        | <span data-ttu-id="6cfbd-770">1574</span><span class="sxs-lookup"><span data-stu-id="6cfbd-770">1574</span></span>      | <span data-ttu-id="6cfbd-771">41738240</span><span class="sxs-lookup"><span data-stu-id="6cfbd-771">41738240</span></span> |
|     |                                             |           |          |
| <span data-ttu-id="6cfbd-772">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-772">EF6</span></span> | <span data-ttu-id="6cfbd-773">ObjectContext-Entity-Befehl</span><span class="sxs-lookup"><span data-stu-id="6cfbd-773">ObjectContext Entity Command</span></span>                | <span data-ttu-id="6cfbd-774">480</span><span class="sxs-lookup"><span data-stu-id="6cfbd-774">480</span></span>       | <span data-ttu-id="6cfbd-775">47247360</span><span class="sxs-lookup"><span data-stu-id="6cfbd-775">47247360</span></span> |
| <span data-ttu-id="6cfbd-776">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-776">EF6</span></span> | <span data-ttu-id="6cfbd-777">ObjectContext-Store-Abfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-777">ObjectContext Store Query</span></span>                   | <span data-ttu-id="6cfbd-778">493</span><span class="sxs-lookup"><span data-stu-id="6cfbd-778">493</span></span>       | <span data-ttu-id="6cfbd-779">46739456</span><span class="sxs-lookup"><span data-stu-id="6cfbd-779">46739456</span></span> |
| <span data-ttu-id="6cfbd-780">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-780">EF6</span></span> | <span data-ttu-id="6cfbd-781">Sql-Abfrage für "DbContext" für Datenbank</span><span class="sxs-lookup"><span data-stu-id="6cfbd-781">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="6cfbd-782">614</span><span class="sxs-lookup"><span data-stu-id="6cfbd-782">614</span></span>       | <span data-ttu-id="6cfbd-783">41607168</span><span class="sxs-lookup"><span data-stu-id="6cfbd-783">41607168</span></span> |
| <span data-ttu-id="6cfbd-784">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-784">EF6</span></span> | <span data-ttu-id="6cfbd-785">Keine nachverfolgung der ObjectContext-Linq-Abfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-785">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="6cfbd-786">684</span><span class="sxs-lookup"><span data-stu-id="6cfbd-786">684</span></span>       | <span data-ttu-id="6cfbd-787">46333952</span><span class="sxs-lookup"><span data-stu-id="6cfbd-787">46333952</span></span> |
| <span data-ttu-id="6cfbd-788">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-788">EF6</span></span> | <span data-ttu-id="6cfbd-789">ObjectContext Entity Sql mit Objektabfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-789">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="6cfbd-790">767</span><span class="sxs-lookup"><span data-stu-id="6cfbd-790">767</span></span>       | <span data-ttu-id="6cfbd-791">48865280</span><span class="sxs-lookup"><span data-stu-id="6cfbd-791">48865280</span></span> |
| <span data-ttu-id="6cfbd-792">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-792">EF6</span></span> | <span data-ttu-id="6cfbd-793">Kompilierte Abfrage ObjectContext</span><span class="sxs-lookup"><span data-stu-id="6cfbd-793">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="6cfbd-794">788</span><span class="sxs-lookup"><span data-stu-id="6cfbd-794">788</span></span>       | <span data-ttu-id="6cfbd-795">48467968</span><span class="sxs-lookup"><span data-stu-id="6cfbd-795">48467968</span></span> |
| <span data-ttu-id="6cfbd-796">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-796">EF6</span></span> | <span data-ttu-id="6cfbd-797">"DbContext" Linq-Abfrage keine nachverfolgung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-797">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="6cfbd-798">878</span><span class="sxs-lookup"><span data-stu-id="6cfbd-798">878</span></span>       | <span data-ttu-id="6cfbd-799">47554560</span><span class="sxs-lookup"><span data-stu-id="6cfbd-799">47554560</span></span> |
| <span data-ttu-id="6cfbd-800">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-800">EF6</span></span> | <span data-ttu-id="6cfbd-801">ObjectContext Linq-Abfrage</span><span class="sxs-lookup"><span data-stu-id="6cfbd-801">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="6cfbd-802">953</span><span class="sxs-lookup"><span data-stu-id="6cfbd-802">953</span></span>       | <span data-ttu-id="6cfbd-803">47632384</span><span class="sxs-lookup"><span data-stu-id="6cfbd-803">47632384</span></span> |
| <span data-ttu-id="6cfbd-804">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-804">EF6</span></span> | <span data-ttu-id="6cfbd-805">Sql-Abfrage für "DbContext" auf "DbSet"</span><span class="sxs-lookup"><span data-stu-id="6cfbd-805">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="6cfbd-806">1023</span><span class="sxs-lookup"><span data-stu-id="6cfbd-806">1023</span></span>      | <span data-ttu-id="6cfbd-807">41992192</span><span class="sxs-lookup"><span data-stu-id="6cfbd-807">41992192</span></span> |
| <span data-ttu-id="6cfbd-808">EF6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-808">EF6</span></span> | <span data-ttu-id="6cfbd-809">Linq-Abfrage für "DbContext"</span><span class="sxs-lookup"><span data-stu-id="6cfbd-809">DbContext Linq Query</span></span>                        | <span data-ttu-id="6cfbd-810">1290</span><span class="sxs-lookup"><span data-stu-id="6cfbd-810">1290</span></span>      | <span data-ttu-id="6cfbd-811">47529984</span><span class="sxs-lookup"><span data-stu-id="6cfbd-811">47529984</span></span> |


![EF5 betriebsbereiten Abfrage 1000 Iterationen](~/ef6/media/ef5warmquery1000.png)

![EF6 betriebsbereiten Abfrage 1000 Iterationen](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> <span data-ttu-id="6cfbd-814">Der Vollständigkeit halber enthalten wir eine Variante, die eine Entity SQL-Abfrage für ein EntityCommand ausführen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-814">For completeness, we included a variation where we execute an Entity SQL query on an EntityCommand.</span></span> <span data-ttu-id="6cfbd-815">Allerdings nicht, da die Ergebnisse für solche Abfragen nicht materialisiert werden, der Vergleich unbedingt Äpfel mit Äpfeln.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-815">However, because results are not materialized for such queries, the comparison isn't necessarily apples-to-apples.</span></span> <span data-ttu-id="6cfbd-816">Der Test umfasst eine weitgehende Annäherung darstellen, wenn Sie versuchen, den Vergleich eine gerechtere materialisieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-816">The test includes a close approximation to materializing to try making the comparison fairer.</span></span>

<span data-ttu-id="6cfbd-817">In diesem Fall End-to-End-Entity Framework 6, Entity Framework 5 aufgrund von leistungsverbesserungen auf mehreren Teilen des Stapels, einschließlich einer viel übersichtlicher "DbContext"-Initialisierung und schnellere MetadataCollection übertrifft&lt;T&gt; Suchvorgänge.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-817">In this end-to-end case, Entity Framework 6 outperforms Entity Framework 5 due to performance improvements made on several parts of the stack, including a much lighter DbContext initialization and faster MetadataCollection&lt;T&gt; lookups.</span></span>

## <a name="7-design-time-performance-considerations"></a><span data-ttu-id="6cfbd-818">7 Design-Time-Leistungsaspekte</span><span class="sxs-lookup"><span data-stu-id="6cfbd-818">7 Design time performance considerations</span></span>

### <a name="71-------inheritance-strategies"></a><span data-ttu-id="6cfbd-819">7.1 Vererbung Strategien</span><span class="sxs-lookup"><span data-stu-id="6cfbd-819">7.1       Inheritance Strategies</span></span>

<span data-ttu-id="6cfbd-820">Eine andere Überlegungen zur Leistung bei Verwendung von Entity Framework ist die Vererbungsstrategie, die Sie verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-820">Another performance consideration when using Entity Framework is the inheritance strategy you use.</span></span> <span data-ttu-id="6cfbd-821">Entitätsframework unterstützt 3 grundlegende Arten der Vererbung sowie deren Kombinationen:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-821">Entity Framework supports 3 basic types of inheritance and their combinations:</span></span>

-   <span data-ttu-id="6cfbd-822">Tabelle pro Hierarchie (TPH) –, in dem jede Vererbung Maps festgelegt, in eine Tabelle mit der eine Unterscheidungsspalte, um anzugeben, welche speziellen Typ in der Hierarchie in der Zeile dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-822">Table per Hierarchy (TPH) – where each inheritance set maps to a table with a discriminator column to indicate which particular type in the hierarchy is being represented in the row.</span></span>
-   <span data-ttu-id="6cfbd-823">Tabelle pro Typ (TPT) –, in denen jeder eine eigene Tabelle in der Datenbank verfügt über. die untergeordneten Tabellen definieren Sie nur die Spalten, die nicht in der übergeordneten Tabelle enthält.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-823">Table per Type (TPT) – where each type has its own table in the database; the child tables only define the columns that the parent table doesn’t contain.</span></span>
-   <span data-ttu-id="6cfbd-824">Tabelle pro Klasse (TPC) –, in denen jeder eine eigene vollständige Tabelle in der Datenbank verfügt über. die untergeordneten Tabellen definieren, allen ihren Feldern, einschließlich der im übergeordneten Typen definiert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-824">Table per Class (TPC) – where each type has its own full table in the database; the child tables define all their fields, including those defined in parent types.</span></span>

<span data-ttu-id="6cfbd-825">Wenn Ihr Modell TPT-Vererbung verwendet wird, werden die Abfragen, die generiert werden komplexer als die sein, die mit den anderen Vererbungsstrategien in längeren Ausführungszeiten im Store zu entstehen generiert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-825">If your model uses TPT inheritance, the queries which are generated will be more complex than those that are generated with the other inheritance strategies, which may result on longer execution times on the store.</span></span>  <span data-ttu-id="6cfbd-826">Im Allgemeinen dauert Abfragen über ein TPT-Modell zu generieren und die resultierenden Objekte materialisiert länger.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-826">It will generally take longer to generate queries over a TPT model, and to materialize the resulting objects.</span></span>

<span data-ttu-id="6cfbd-827">Finden Sie unter den "Überlegungen zur Leistung bei Verwendung von (Tabelle pro Typ)-TPT-Vererbung im Entitätsframework" MSDN-Blogbeitrag: \<http://blogs.msdn.com/b/adonet/archive/2010/08/17/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-827">See the "Performance Considerations when using TPT (Table per Type) Inheritance in the Entity Framework" MSDN blog post: \<http://blogs.msdn.com/b/adonet/archive/2010/08/17/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework.aspx>.</span></span>

#### <a name="711-------avoiding-tpt-in-model-first-or-code-first-applications"></a><span data-ttu-id="6cfbd-828">7.1.1 Vermeiden von TPT in Model First oder Code First-Anwendungen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-828">7.1.1       Avoiding TPT in Model First or Code First applications</span></span>

<span data-ttu-id="6cfbd-829">Wenn Sie ein Modell über eine vorhandene Datenbank, die eine TPT-Schema aufweist erstellen, müssen Sie nicht viele Optionen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-829">When you create a model over an existing database that has a TPT schema, you don't have many options.</span></span> <span data-ttu-id="6cfbd-830">Aber wenn Sie eine Anwendung mit Model First oder Code First zu erstellen, sollten Sie TPT-Vererbung für Bedenken hinsichtlich der Leistung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-830">But when creating an application using Model First or Code First, you should avoid TPT inheritance for performance concerns.</span></span>

<span data-ttu-id="6cfbd-831">Wenn Sie Model First im Entity Designer-Assistenten verwenden, erhalten Sie TPT für die Vererbung in Ihrem Modell.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-831">When you use Model First in the Entity Designer Wizard, you will get TPT for any inheritance in your model.</span></span> <span data-ttu-id="6cfbd-832">Wenn Sie in eine TPH-Vererbung-Strategie mit Model First wechseln möchten, können Sie die "Entity Designer Datenbank Generation Power Pack" zur Verfügung verwenden, aus der Visual Studio Gallery ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-832">If you want to switch to a TPH inheritance strategy with Model First, you can use the "Entity Designer Database Generation Power Pack" available from the Visual Studio Gallery ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span></span>

<span data-ttu-id="6cfbd-833">Bei Code First verwenden, um die Zuordnung eines Modells mit '-Vererbung konfigurieren, EF verwendet standardmäßig TPH, daher werden alle Entitäten in der Vererbungshierarchie zu derselben Tabelle zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-833">When using Code First to configure the mapping of a model with inheritance, EF will use TPH by default, therefore all entities in the inheritance hierarchy will be mapped to the same table.</span></span> <span data-ttu-id="6cfbd-834">Finden Sie im Abschnitt "Zuordnung mit der Fluent-API" des Artikels "Code zuerst in Entity Framework4.1" im MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) Weitere Informationen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-834">See the "Mapping with the Fluent API" section of the "Code First in Entity Framework4.1" article in MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) for more details.</span></span>

### <a name="72-------upgrading-from-ef4-to-improve-model-generation-time"></a><span data-ttu-id="6cfbd-835">7.2 Aktualisieren von EF4 zur Verbesserung der modellgenerierung Zeit</span><span class="sxs-lookup"><span data-stu-id="6cfbd-835">7.2       Upgrading from EF4 to improve model generation time</span></span>

<span data-ttu-id="6cfbd-836">Eine SQL Server-spezifische Verbesserung für den Algorithmus, der generiert die Store-Ebene (SSDL) des Modells ist in Entity Framework 5 und 6, und als Update für Entity Framework 4 verfügbar, wenn Visual Studio 2010 SP1 installiert ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-836">A SQL Server-specific improvement to the algorithm that generates the store-layer (SSDL) of the model is available in Entity Framework 5 and 6, and as an update to Entity Framework 4 when Visual Studio 2010 SP1 is installed.</span></span> <span data-ttu-id="6cfbd-837">Die folgenden Testergebnisse zeigen die Verbesserung beim Generieren eines großen Modells in diesem Fall das Navision-Modell.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-837">The following test results demonstrate the improvement when generating a very big model, in this case the Navision model.</span></span> <span data-ttu-id="6cfbd-838">Weitere Details finden Sie unter Anhang C.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-838">See Appendix C for more details about it.</span></span>

<span data-ttu-id="6cfbd-839">Das Modell enthält 1005 Entitätenmengen und Zuordnungssätze 4227.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-839">The model contains 1005 entity sets and 4227 association sets.</span></span>

| <span data-ttu-id="6cfbd-840">Konfiguration</span><span class="sxs-lookup"><span data-stu-id="6cfbd-840">Configuration</span></span>                              | <span data-ttu-id="6cfbd-841">Aufschlüsselung der verbrauchte Zeit</span><span class="sxs-lookup"><span data-stu-id="6cfbd-841">Breakdown of time consumed</span></span>                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="6cfbd-842">Visual Studio 2010 Entitätsframework 4</span><span class="sxs-lookup"><span data-stu-id="6cfbd-842">Visual Studio 2010, Entity Framework 4</span></span>     | <span data-ttu-id="6cfbd-843">SSDL-Generierung: 2 Std. 27 Min.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-843">SSDL Generation: 2 hr 27 min</span></span> <br/> <span data-ttu-id="6cfbd-844">Zuordnung generieren: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-844">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-845">CSDL-Generierung: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-845">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-846">ObjectLayer generieren: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-846">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-847">Generieren von Sichten: 2 h 14 Min.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-847">View Generation: 2 h 14 min</span></span> |
| <span data-ttu-id="6cfbd-848">Visual Studio 2010 SP1, Entitätsframework 4</span><span class="sxs-lookup"><span data-stu-id="6cfbd-848">Visual Studio 2010 SP1, Entity Framework 4</span></span> | <span data-ttu-id="6cfbd-849">SSDL-Generierung: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-849">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-850">Zuordnung generieren: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-850">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-851">CSDL-Generierung: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-851">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-852">ObjectLayer generieren: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-852">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-853">Generieren von Sichten: 1 Std. 53 Min.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-853">View Generation: 1 hr 53 min</span></span>   |
| <span data-ttu-id="6cfbd-854">Visual Studio 2013, Entitätsframework 5</span><span class="sxs-lookup"><span data-stu-id="6cfbd-854">Visual Studio 2013, Entity Framework 5</span></span>     | <span data-ttu-id="6cfbd-855">SSDL-Generierung: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-855">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-856">Zuordnung generieren: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-856">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-857">CSDL-Generierung: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-857">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-858">ObjectLayer generieren: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-858">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-859">Generieren von Sichten: 65 Minuten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-859">View Generation: 65 minutes</span></span>    |
| <span data-ttu-id="6cfbd-860">Visual Studio 2013, Entitätsframework 6</span><span class="sxs-lookup"><span data-stu-id="6cfbd-860">Visual Studio 2013, Entity Framework 6</span></span>     | <span data-ttu-id="6cfbd-861">SSDL-Generierung: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-861">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-862">Zuordnung generieren: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-862">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-863">CSDL-Generierung: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-863">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-864">ObjectLayer generieren: 1 Sekunde</span><span class="sxs-lookup"><span data-stu-id="6cfbd-864">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="6cfbd-865">Generieren von Sichten: 28 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-865">View Generation: 28 seconds.</span></span>   |


<span data-ttu-id="6cfbd-866">Es ist erwähnenswert, dass beim SSDL zu generieren, die Last fast ausschließlich auf dem SQL-Server aufgewendet wird während der Client-Entwicklungscomputer wartet im Leerlauf, für die Ergebnisse vom Server zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-866">It's worth noting that when generating the SSDL, the load is almost entirely spent on the SQL Server, while the client development machine is waiting idle for results to come back from the server.</span></span> <span data-ttu-id="6cfbd-867">Datenbankadministratoren sollten besonders, dass diese Verbesserung zu schätzen wissen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-867">DBAs should particularly appreciate this improvement.</span></span> <span data-ttu-id="6cfbd-868">Es ist auch erwähnenswert, dass im Wesentlichen die Gesamtkosten der Modellerstellung im Generieren von Sichten jetzt stattfindet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-868">It's also worth noting that essentially the entire cost of model generation takes place in View Generation now.</span></span>

### <a name="73-------splitting-large-models-with-database-first-and-model-first"></a><span data-ttu-id="6cfbd-869">7.3 Teilen Sie große Modelle mit Datenbank zuerst und Model First</span><span class="sxs-lookup"><span data-stu-id="6cfbd-869">7.3       Splitting Large Models with Database First and Model First</span></span>

<span data-ttu-id="6cfbd-870">Mit zunehmender Größe des Datenbankmodells wird die Oberfläche des Designers überladen und schwierig zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-870">As model size increases, the designer surface becomes cluttered and difficult to use.</span></span> <span data-ttu-id="6cfbd-871">In der Regel betrachten wir ein Modell mit mehr als 300 Entitäten, zu groß, um effektiv der Designer verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-871">We typically consider a model with more than 300 entities to be too large to effectively use the designer.</span></span> <span data-ttu-id="6cfbd-872">Im folgenden Blogbeitrag beschreibt mehrere Optionen für das Aufteilen von großer Models: \<http://blogs.msdn.com/b/adonet/archive/2008/11/25/working-with-large-models-in-entity-framework-part-2.aspx>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-872">The following blog post describes several options for splitting large models: \<http://blogs.msdn.com/b/adonet/archive/2008/11/25/working-with-large-models-in-entity-framework-part-2.aspx>.</span></span>

<span data-ttu-id="6cfbd-873">Der Beitrag wurde für die erste Version von Entity Framework geschrieben, aber die Schritte gelten weiterhin.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-873">The post was written for the first version of Entity Framework, but the steps still apply.</span></span>

### <a name="74-------performance-considerations-with-the-entity-data-source-control"></a><span data-ttu-id="6cfbd-874">7.4-leistungsüberlegungen zu Entity Datenquellen-Steuerelements</span><span class="sxs-lookup"><span data-stu-id="6cfbd-874">7.4       Performance considerations with the Entity Data Source Control</span></span>

<span data-ttu-id="6cfbd-875">Wir haben gesehen Fälle im Multithread-Leistungs- und Belastungstests, wirkt sich negativ auf die Leistung einer Webanwendung, die über das EntityDataSource-Steuerelement deutlich.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-875">We've seen cases in multi-threaded performance and stress tests where the performance of a web application using the EntityDataSource Control deteriorates significantly.</span></span> <span data-ttu-id="6cfbd-876">Die zugrunde liegende Ursache ist, dass das EntityDataSource wiederholt MetadataWorkspace.LoadFromAssembly auf den verwiesen wird, von der Webanwendung zum Ermitteln der Typen, die als Entitäten verwendet werden Assemblys aufruft.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-876">The underlying cause is that the EntityDataSource repeatedly calls MetadataWorkspace.LoadFromAssembly on the assemblies referenced by the Web application to discover the types to be used as entities.</span></span>

<span data-ttu-id="6cfbd-877">Die Lösung besteht darin, dem "ContextTypeName" von EntityDataSource auf den Namen der abgeleiteten Klasse ObjectContext festgelegt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-877">The solution is to set the ContextTypeName of the EntityDataSource to the type name of your derived ObjectContext class.</span></span> <span data-ttu-id="6cfbd-878">Dadurch wird der Mechanismus, der alle referenzierten Assemblys für Entitätstypen scannt deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-878">This turns off the mechanism that scans all referenced assemblies for entity types.</span></span>

<span data-ttu-id="6cfbd-879">Festlegen des Felds "ContextTypeName" wird verhindert, dass auch ein funktionales Problem, in dem das EntityDataSource in .NET 4.0 ReflectionTypeLoadException löst aus, wenn einen Typ nicht aus einer Assembly über Reflektion geladen werden können.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-879">Setting the ContextTypeName field also prevents a functional problem where the EntityDataSource in .NET 4.0 throws a ReflectionTypeLoadException when it can't load a type from an assembly via reflection.</span></span> <span data-ttu-id="6cfbd-880">Dieses Problem wurde in .NET 4.5 behoben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-880">This issue has been fixed in .NET 4.5.</span></span>

### <a name="75-------poco-entities-and-change-tracking-proxies"></a><span data-ttu-id="6cfbd-881">7.5 POCO-Entitäten und Proxys mit änderungsnachverfolgung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-881">7.5       POCO entities and change tracking proxies</span></span>

<span data-ttu-id="6cfbd-882">Entitätsframework ermöglicht Ihnen, benutzerdefinierte Datenklassen zusammen mit dem Datenmodell zu verwenden, ohne Änderungen an den Datenklassen selbst vornehmen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-882">Entity Framework enables you to use custom data classes together with your data model without making any modifications to the data classes themselves.</span></span> <span data-ttu-id="6cfbd-883">Dies bedeutet, dass Sie POCO-Objekte (Plain-old CLR objects), z. B. vorhandene Domänenobjekte, mit dem Datenmodell verwenden können.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-883">This means that you can use "plain-old" CLR objects (POCO), such as existing domain objects, with your data model.</span></span> <span data-ttu-id="6cfbd-884">Diese POCO-Datenklassen (auch bekannt als Dauerhaftigkeit ignorierende Objekte), die auf Entitäten zugeordnet sind, die in einem Datenmodell definiert sind, unterstützen die meisten derselben Abfrage, einfügen, aktualisieren und Löschverhalten wie Entitätstypen, die von den Entity Data Model-Tools generiert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-884">These POCO data classes (also known as persistence-ignorant objects), which are mapped to entities that are defined in a data model, support most of the same query, insert, update, and delete behaviors as entity types that are generated by the Entity Data Model tools.</span></span>

<span data-ttu-id="6cfbd-885">Entitätsframework kann auch erstellen die Webdienstproxy-Klassen abgeleitet aus den POCO-Typen, die verwendet werden, wenn Sie Funktionen wie lazy Loading und automatischen Nachverfolgen von Änderungen in POCO-Entitäten aktivieren möchten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-885">Entity Framework can also create proxy classes derived from your POCO types, which are used when you want to enable features such as lazy loading and automatic change tracking on POCO entities.</span></span> <span data-ttu-id="6cfbd-886">Die POCO-Klassen müssen bestimmte Anforderungen Entity Framework, Proxys verwenden können, wie hier beschrieben: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-886">Your POCO classes must meet certain requirements to allow Entity Framework to use proxies, as described here: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span></span>

<span data-ttu-id="6cfbd-887">Wahrscheinlichkeit Änderungsnachverfolgungsproxys benachrichtigt den Objekt-Status-Manager jedes Mal, die die Eigenschaften der Entität verfügt über einen Wert, der geändert, damit Entity Framework den tatsächlichen Zustand der Entitäten immer weiß, dass.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-887">Chance tracking proxies will notify the object state manager each time any of the properties of your entities has its value changed, so Entity Framework knows the actual state of your entities all the time.</span></span> <span data-ttu-id="6cfbd-888">Dies ist der Text, der den Setter-Methoden, Eigenschaften des Benachrichtigungsereignisse hinzugefügt wird und des Objekt-Status-Managers, die derartige Ereignisse verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-888">This is done by adding notification events to the body of the setter methods of your properties, and having the object state manager processing such events.</span></span> <span data-ttu-id="6cfbd-889">Hinweis: Erstellen eines Proxys in der Regel wird der Entität werden teurer als eine nicht-Proxy-POCO-Entität aufgrund von den hinzugefügten Satz von Ereignissen, die von Entity Framework erstellte erstellen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-889">Note that creating a proxy entity will typically be more expensive than creating a non-proxy POCO entity due to the added set of events created by Entity Framework.</span></span>

<span data-ttu-id="6cfbd-890">Wenn eine POCO-Entität ein Proxy für die änderungsnachverfolgung nicht besitzt, werden Änderungen durch vergleichen den Inhalt Ihrer Entitäten mit der Kopie einen zuvor gespeicherten Zustand gefunden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-890">When a POCO entity does not have a change tracking proxy, changes are found by comparing the contents of your entities against a copy of a previous saved state.</span></span> <span data-ttu-id="6cfbd-891">Diese umfassende Vergleich werden ein langwieriger Prozess Wenn viele Entitäten in den Kontext verfügbar ist oder wenn Ihre Entitäten über eine große Menge von Eigenschaften haben, auch wenn keine von ihnen geändert, seit der letzten Vergleich.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-891">This deep comparison will become a lengthy process when you have many entities in your context, or when your entities have a very large amount of properties, even if none of them changed since the last comparison took place.</span></span>

<span data-ttu-id="6cfbd-892">Zusammenfassung: Sie Zahlen eine Leistungseinbuße, wenn es sich bei die änderungsnachverfolgung mit Proxys erstellen, aber die änderungsnachverfolgung können Sie den Erkennungsprozess Änderung beschleunigen, wenn die Entitäten haben viele Eigenschaften oder wenn Sie viele Entitäten in Ihrem Modell.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-892">In summary: you’ll pay a performance hit when creating the change tracking proxy, but change tracking will help you speed up the change detection process when your entities have many properties or when you have many entities in your model.</span></span> <span data-ttu-id="6cfbd-893">Für Entitäten mit einer kleinen Anzahl von Eigenschaften, in denen die Menge von Entitäten zu viel wachsen nicht, mit Change Tracking-Proxys viel Vorteil möglicherweise nicht.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-893">For entities with a small number of properties where the amount of entities doesn’t grow too much, having change tracking proxies may not be of much benefit.</span></span>

## <a name="8-loading-related-entities"></a><span data-ttu-id="6cfbd-894">8 Laden von verknüpften Entitäten</span><span class="sxs-lookup"><span data-stu-id="6cfbd-894">8 Loading Related Entities</span></span>

### <a name="81-lazy-loading-vs-eager-loading"></a><span data-ttu-id="6cfbd-895">8.1 Lazy Loading im Vergleich zu Eager Loading</span><span class="sxs-lookup"><span data-stu-id="6cfbd-895">8.1 Lazy Loading vs. Eager Loading</span></span>

<span data-ttu-id="6cfbd-896">Entitätsframework bietet verschiedene Möglichkeiten, die Entitäten zu laden, die im Zusammenhang mit der Zielentität.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-896">Entity Framework offers several different ways to load the entities that are related to your target entity.</span></span> <span data-ttu-id="6cfbd-897">Z. B. Wenn Sie Produkte abzufragen, es gibt verschiedene Möglichkeiten, die verknüpften Bestellungen geladen werden in den Zustands-Manager-Objekt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-897">For example, when you query for Products, there are different ways that the related Orders will be loaded into the Object State Manager.</span></span> <span data-ttu-id="6cfbd-898">Vom Standpunkt der Leistung wird die größte Frage beim Laden von verknüpften Entitäten zu berücksichtigen, ob Lazy Loading oder Eager Loading verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-898">From a performance standpoint, the biggest question to consider when loading related entities will be whether to use Lazy Loading or Eager Loading.</span></span>

<span data-ttu-id="6cfbd-899">Wenn Sie Eager Loading verwenden, werden die verknüpften Entitäten zusammen mit Ihrer Zielentitätenmenge geladen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-899">When using Eager Loading, the related entities are loaded along with your target entity set.</span></span> <span data-ttu-id="6cfbd-900">Sie verwenden eine Include-Anweisung in der Abfrage an, um anzugeben, die verknüpften Entitäten, die Sie importieren möchten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-900">You use an Include statement in your query to indicate which related entities you want to bring in.</span></span>

<span data-ttu-id="6cfbd-901">Wenn Sie Lazy Loading verwenden, übernimmt die ursprüngliche Abfrage nur die zielentitätssammlung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-901">When using Lazy Loading, your initial query only brings in the target entity set.</span></span> <span data-ttu-id="6cfbd-902">Jedoch wenn Sie Zugriff auf eine Navigationseigenschaft, für den Speicher laden Sie die verknüpfte Entität einer anderen Abfrage ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-902">But whenever you access a navigation property, another query is issued against the store to load the related entity.</span></span>

<span data-ttu-id="6cfbd-903">Sobald eine Entität geladen wurde, lädt alle weiteren Abfragen für die Entität es direkt aus dem Objekt-Status-Manager, ob Sie lazy Loading oder eager Loading verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-903">Once an entity has been loaded, any further queries for the entity will load it directly from the Object State Manager, whether you are using lazy loading or eager loading.</span></span>

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a><span data-ttu-id="6cfbd-904">8.2 wie zwischen Lazy Loading und Eager Loading</span><span class="sxs-lookup"><span data-stu-id="6cfbd-904">8.2 How to choose between Lazy Loading and Eager Loading</span></span>

<span data-ttu-id="6cfbd-905">Wichtig ist, dass Sie den Unterschied zwischen Lazy Loading und Eager Loading verstehen, sodass Sie die richtige Wahl für Ihre Anwendung vornehmen können.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-905">The important thing is that you understand the difference between Lazy Loading and Eager Loading so that you can make the correct choice for your application.</span></span> <span data-ttu-id="6cfbd-906">Dies können Sie den Kompromiss zwischen mehrere Anforderungen für die Datenbank im Vergleich zu einer einzelnen Anforderung zu bewerten, die eine große Nutzlast enthalten können.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-906">This will help you evaluate the tradeoff between multiple requests against the database versus a single request that may contain a large payload.</span></span> <span data-ttu-id="6cfbd-907">Es kann mit eager Loading in einigen Teilen der Anwendung und lazy Loading in anderen Teilen geeignet sein.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-907">It may be appropriate to use eager loading in some parts of your application and lazy loading in other parts.</span></span>

<span data-ttu-id="6cfbd-908">Nehmen wir an, dass Sie für die Kunden Abfragen, die im Vereinigten Königreich und die Anzahl der Bestellungen Leben möchten, beispielsweise davon, was hinter den Kulissen passiert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-908">As an example of what's happening under the hood, suppose you want to query for the customers who live in the UK and their order count.</span></span>

<span data-ttu-id="6cfbd-909">**Verwenden Eager Loading**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-909">**Using Eager Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="6cfbd-910">**Verwendung von Lazy Loading**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-910">**Using Lazy Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="6cfbd-911">Wenn Sie eager Loading verwenden zu können, müssen Sie eine einzelne Abfrage, die alle Kunden zurückgibt ausgeben und alle Aufträge.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-911">When using eager loading, you'll issue a single query that returns all customers and all orders.</span></span> <span data-ttu-id="6cfbd-912">Der Speicherbefehl sieht folgendermaßen aus:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-912">The store command looks like:</span></span>

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

<span data-ttu-id="6cfbd-913">Wenn lazy Loading verwenden zu können, müssen Sie zunächst die folgende Abfrage ausgeben:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-913">When using lazy loading, you'll issue the following query initially:</span></span>

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

<span data-ttu-id="6cfbd-914">Und jedes Mal, die Sie Zugriff auf die Navigationseigenschaft von Bestellungen eines Kunden für den Speicher wird eine andere Abfrage wie folgt ausgegeben:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-914">And each time you access the Orders navigation property of a customer another query like the following is issued against the store:</span></span>

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

<span data-ttu-id="6cfbd-915">Weitere Informationen finden Sie unter den [laden verbundener Objekte](https://msdn.microsoft.com/library/bb896272.aspx).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-915">For more information, see the [Loading Related Objects](https://msdn.microsoft.com/library/bb896272.aspx).</span></span>

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a><span data-ttu-id="6cfbd-916">8.2.1 Lazy Loading im Vergleich zu Eager Loading Cheat Sheet für Algorithmen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-916">8.2.1 Lazy Loading versus Eager Loading cheat sheet</span></span>

<span data-ttu-id="6cfbd-917">Es gibt keine als eine allgemeingültige Eager Load und Lazy Load auswählen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-917">There’s no such thing as a one-size-fits-all to choosing eager loading versus lazy loading.</span></span> <span data-ttu-id="6cfbd-918">Zuerst versucht, die zu den Unterschieden zwischen beide Strategien, damit Sie gut informierte Entscheidung tun können; Beachten Sie auch, ob Ihr Code auf eine der folgenden Szenarien geeignet ist:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-918">Try first to understand the differences between both strategies so you can do a well informed decision; also, consider if your code fits to any of the following scenarios:</span></span>

| <span data-ttu-id="6cfbd-919">Szenario</span><span class="sxs-lookup"><span data-stu-id="6cfbd-919">Scenario</span></span>                                                                    | <span data-ttu-id="6cfbd-920">Unsere Empfehlung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-920">Our Suggestion</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="6cfbd-921">Möchten Sie die abgerufenen Entitäten viele Navigationseigenschaften zugreifen?</span><span class="sxs-lookup"><span data-stu-id="6cfbd-921">Do you need to access many navigation properties from the fetched entities?</span></span> | <span data-ttu-id="6cfbd-922">**Keine** – beide Optionen werden wahrscheinlich der Fall.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-922">**No** - Both options will probably do.</span></span> <span data-ttu-id="6cfbd-923">Allerdings ist die Nutzlast, die die Abfrage eingebunden wurde nicht zu groß ist, auftreten können, die Leistungsvorteile mit unverzüglichem Laden, da es weniger erfordern werden Netzwerkroundtrips um die Objekte zu materialisieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-923">However, if the payload your query is bringing is not too big, you may experience performance benefits by using Eager loading as it’ll require less network round trips to materialize your objects.</span></span> <br/> <br/> <span data-ttu-id="6cfbd-924">**Ja** – Wenn Sie viele Navigationseigenschaften aus den Entitäten zugreifen müssen, würden Sie tun, indem Sie mehrere Anweisungen, in der Abfrage mit unverzüglichem Laden enthalten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-924">**Yes** -  If you need to access many navigation properties from the entities, you’d do that by using multiple include statements in your query with Eager loading.</span></span> <span data-ttu-id="6cfbd-925">Weitere Entitäten eingeschlossen werden, desto größer wird die Nutzlast die Abfrage zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-925">The more entities you include, the bigger the payload your query will return.</span></span> <span data-ttu-id="6cfbd-926">Nachdem Sie drei oder mehr Entitäten in die Abfrage einschließen, wechseln Sie ggf. zu verzögerten Laden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-926">Once you include three or more entities into your query, consider switching to Lazy loading.</span></span> |
| <span data-ttu-id="6cfbd-927">Wissen Sie, welche Daten genau zur Laufzeit benötigt werden?</span><span class="sxs-lookup"><span data-stu-id="6cfbd-927">Do you know exactly what data will be needed at run time?</span></span>                   | <span data-ttu-id="6cfbd-928">**Keine** -Lazy Loading werden besser für Sie.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-928">**No** - Lazy loading will be better for you.</span></span> <span data-ttu-id="6cfbd-929">Sie können, andernfalls beenden Sie, dass Sie nicht benötigen Daten Abfragen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-929">Otherwise, you may end up querying for data that you will not need.</span></span> <br/> <br/> <span data-ttu-id="6cfbd-930">**Ja** – Eager Loading ist wahrscheinlich die beste Lösung, es hilft beim gesamten legt schneller geladen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-930">**Yes** - Eager loading is probably your best bet; it will help loading entire sets faster.</span></span> <span data-ttu-id="6cfbd-931">Wenn Ihre Abfrage erfordert eine sehr große Datenmenge abrufen, und dies zu langsam wird, wiederholen Sie dann stattdessen Laden verzögert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-931">If your query requires fetching a very large amount of data, and this becomes too slow, then try Lazy loading instead.</span></span>                                                                                                                                                                                                                                                       |
| <span data-ttu-id="6cfbd-932">Werden der Code ist weit entfernt von der Datenbank ausgeführt?</span><span class="sxs-lookup"><span data-stu-id="6cfbd-932">Is your code executing far from your database?</span></span> <span data-ttu-id="6cfbd-933">(erhöhte Netzwerklatenz)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-933">(increased network latency)</span></span>  | <span data-ttu-id="6cfbd-934">**Keine** : Wenn die Netzwerklatenz kein Problem dar, ist möglicherweise bei Verwendung von Lazy Loading Ihren Code vereinfachen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-934">**No** - When the network latency is not an issue, using Lazy loading may simplify your code.</span></span> <span data-ttu-id="6cfbd-935">Denken Sie daran, dass die Topologie Ihrer Anwendung also Datenbank NEAR als selbstverständlich nicht ändern kann.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-935">Remember that the topology of your application may change, so don’t take database proximity for granted.</span></span> <br/> <br/> <span data-ttu-id="6cfbd-936">**Ja** : Wenn das Netzwerk ein Problem ist, nur Sie entscheiden können, was für Ihr Szenario besser geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-936">**Yes** - When the network is a problem, only you can decide what fits better for your scenario.</span></span> <span data-ttu-id="6cfbd-937">Eager Loading wird in der Regel besser sein, da weniger Roundtrips erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-937">Typically Eager loading will be better because it requires fewer round trips.</span></span>                                                                                                                                                                                                      |


#### <a name="822-------performance-concerns-with-multiple-includes"></a><span data-ttu-id="6cfbd-938">8.2.2 Leistungsbedenken mit mehreren enthält</span><span class="sxs-lookup"><span data-stu-id="6cfbd-938">8.2.2       Performance concerns with multiple Includes</span></span>

<span data-ttu-id="6cfbd-939">Wenn wir Fragen zur Performance, die Zeit von Serverproblemen-Antwort enthalten hören, ist die Quelle des Problems häufig Abfragen mit mehreren Include-Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-939">When we hear performance questions that involve server response time problems, the source of the issue is frequently queries with multiple Include statements.</span></span> <span data-ttu-id="6cfbd-940">Während einschließlich verknüpfte Entitäten in einer Abfrage leistungsfähig ist, ist es wichtig zu verstehen, was hinter den Kulissen passiert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-940">While including related entities in a query is powerful, it's important to understand what's happening under the covers.</span></span>

<span data-ttu-id="6cfbd-941">Es dauert relativ lange dauert, bis eine Abfrage mit mehreren Include-Anweisungen, um unsere internen Plan Compiler erstellt den Speicherbefehl zu durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-941">It takes a relatively long time for a query with multiple Include statements in it to go through our internal plan compiler to produce the store command.</span></span> <span data-ttu-id="6cfbd-942">Der Großteil dieser Zeit ist hat versucht, die sich ergebende Abfrage zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-942">The majority of this time is spent trying to optimize the resulting query.</span></span> <span data-ttu-id="6cfbd-943">Der generierte Speicherbefehl enthält einer Outer Join oder Union für jede einschließen, je nach Ihrer Zuordnung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-943">The generated store command will contain an Outer Join or Union for each Include, depending on your mapping.</span></span> <span data-ttu-id="6cfbd-944">Derartige Abfragen werden in großen verbundene Diagramme aus der Datenbank in einer einzelnen Nutzlast, anzuzeigen, in dem alle Bandbreitenprobleme acerbate wird, insbesondere, wenn Sie viele der Redundanz in der Nutzlast (z. B., wenn mehrere Ebenen von Include verwendet werden, durchlaufen Zuordnungen in der 1: n Richtung).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-944">Queries like this will bring in large connected graphs from your database in a single payload, which will acerbate any bandwidth issues, especially when there is a lot of redundancy in the payload (for example, when multiple levels of Include are used to traverse associations in the one-to-many direction).</span></span>

<span data-ttu-id="6cfbd-945">Sehen Sie sich für Fälle, in denen Ihre Abfragen übermäßig große Nutzlasten zurückgegeben werden, durch den Zugriff auf das zugrunde liegende TSQL für die Abfrage von ToTraceString verwenden und in SQL Server Management Studio, um die Größe der Nutzlast finden Sie unter der Store-Befehl ausführen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-945">You can check for cases where your queries are returning excessively large payloads by accessing the underlying TSQL for the query by using ToTraceString and executing the store command in SQL Server Management Studio to see the payload size.</span></span> <span data-ttu-id="6cfbd-946">Führen Sie in solchen Fällen können Sie versuchen, reduzieren die Anzahl der Include-Anweisungen in der Abfrage nur die benötigten Daten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-946">In such cases you can try to reduce the number of Include statements in your query to just bring in the data you need.</span></span> <span data-ttu-id="6cfbd-947">Oder Sie Ihre Abfrage in eine kleinere Unterabfragen, z. B. aufteilen:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-947">Or you may be able to break your query into a smaller sequence of subqueries, for example:</span></span>

<span data-ttu-id="6cfbd-948">**Vor dem Unterbrechen der Abfrage ein:**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-948">**Before breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="6cfbd-949">**Nach der aktuellen Abfrage an:**</span><span class="sxs-lookup"><span data-stu-id="6cfbd-949">**After breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="6cfbd-950">Dies funktioniert nur für nachverfolgte Abfragen, wie wir machen verwenden die Möglichkeit, die der Kontext zum automatischen Ausführen von Identity-Auflösung und Zuordnung Fixup wurde.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-950">This will work only on tracked queries, as we are making use of the ability the context has to perform identity resolution and association fixup automatically.</span></span>

<span data-ttu-id="6cfbd-951">Wie bei lazy Loading werden der Nachteil hierbei mehr Abfragen für geringere Nutzlasten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-951">As with lazy loading, the tradeoff will be more queries for smaller payloads.</span></span> <span data-ttu-id="6cfbd-952">Sie können auch Projektionen der einzelnen Eigenschaften explizit nur die benötigten Daten aus jeder Entität auswählen, aber nicht laden Sie Entitäten in diesem Fall und Updates werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-952">You can also use projections of individual properties to explicitly select only the data you need from each entity, but you will not be loading entities in this case, and updates will not be supported.</span></span>

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a><span data-ttu-id="6cfbd-953">8.2.3-problemumgehung für das verzögerte Laden von Eigenschaften zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-953">8.2.3 Workaround to get lazy loading of properties</span></span>

<span data-ttu-id="6cfbd-954">Entitätsframework unterstützt derzeit keine lazy Loading von skalaren oder komplexen Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-954">Entity Framework currently doesn’t support lazy loading of scalar or complex properties.</span></span> <span data-ttu-id="6cfbd-955">Allerdings in Fällen, in dem Sie eine Tabelle verfügen, die ein großes Objekt wie ein BLOB enthält, können Sie die tabellenaufteilung große Eigenschaften in eine getrennte Entität getrennt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-955">However, in cases where you have a table that includes a large object such as a BLOB, you can use table splitting to separate the large properties into a separate entity.</span></span> <span data-ttu-id="6cfbd-956">Nehmen wir beispielsweise an, dass Sie über eine Product-Tabelle verfügen, die eine Varbinary-Spalte Photo enthält.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-956">For example, suppose you have a Product table that includes a varbinary photo column.</span></span> <span data-ttu-id="6cfbd-957">Wenn Sie häufig Zugriff auf diese Eigenschaft in Ihren Abfragen nicht möchten, können Sie die Tabelle aufteilen, um nur die Teile der Entität zu importieren, die Sie normalerweise benötigen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-957">If you don't frequently need to access this property in your queries, you can use table splitting to bring in only the parts of the entity that you normally need.</span></span> <span data-ttu-id="6cfbd-958">Die Entität, die das Produktfoto darstellt wird nur bei Bedarf explizit geladen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-958">The entity representing the product photo will only be loaded when you explicitly need it.</span></span>

<span data-ttu-id="6cfbd-959">Eine gute Ressource, die zeigt, wie die tabellenaufteilung aktiviert ist, die Gil Fink "Tabelle Aufteilen in Entity Framework"-Blogbeitrag: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-959">A good resource that shows how to enable table splitting is Gil Fink's "Table Splitting in Entity Framework" blog post: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span></span>

## <a name="9-other-considerations"></a><span data-ttu-id="6cfbd-960">9 Weitere Überlegungen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-960">9 Other considerations</span></span>

### <a name="91------server-garbage-collection"></a><span data-ttu-id="6cfbd-961">9.1 Garbagecollection-server</span><span class="sxs-lookup"><span data-stu-id="6cfbd-961">9.1      Server Garbage Collection</span></span>

<span data-ttu-id="6cfbd-962">Einige Benutzer können Ressourcenkonflikte auftreten, die die Parallelität einschränkt, die sie erwarten, wenn der Garbage Collector nicht ordnungsgemäß konfiguriert ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-962">Some users might experience resource contention that limits the parallelism they are expecting when the Garbage Collector is not properly configured.</span></span> <span data-ttu-id="6cfbd-963">Wenn EF in einem Multithread-Szenario verwendet wird, oder in einer beliebigen Anwendung, die eine serverseitige System ähnelt, stellen Sie sicher, dass Garbage Collection auf dem Server zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-963">Whenever EF is used in a multithreaded scenario, or in any application that resembles a server-side system, make sure to enable Server Garbage Collection.</span></span> <span data-ttu-id="6cfbd-964">Dies erfolgt über eine einfache Einstellung in der Konfigurationsdatei der Anwendung:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-964">This is done via a simple setting in your application config file:</span></span>

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

<span data-ttu-id="6cfbd-965">Dies sollte Ihre Threadkonflikte verringern und den Durchsatz erhöhen, indem Sie bis zu 30 % in CPU-Kapazität erschöpft-Szenarien.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-965">This should decrease your thread contention and increase your throughput by up to 30% in CPU saturated scenarios.</span></span> <span data-ttu-id="6cfbd-966">Im Allgemeinen sollten Sie immer testen, das Anwendungsverhalten mit der klassischen Garbage Collection (die besser für die Benutzeroberfläche und Client-Seite-Szenarien optimiert ist) sowie die Garbage Collection auf dem Server.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-966">In general terms, you should always test how your application behaves using the classic Garbage Collection (which is better tuned for UI and client side scenarios) as well as the Server Garbage Collection.</span></span>

### <a name="92------autodetectchanges"></a><span data-ttu-id="6cfbd-967">9.2 AutoDetectChanges</span><span class="sxs-lookup"><span data-stu-id="6cfbd-967">9.2      AutoDetectChanges</span></span>

<span data-ttu-id="6cfbd-968">Wie bereits erwähnt, kann Entity Framework Leistungsprobleme angezeigt, wenn es sich bei der Objektcache viele Entitäten verfügt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-968">As mentioned earlier, Entity Framework might show performance issues when the object cache has many entities.</span></span> <span data-ttu-id="6cfbd-969">Bestimmte Vorgänge, z. B. hinzufügen "," entfernen "," Suchen "," Eintrag "und" SaveChanges ", lösen Aufrufe von DetectChanges die verwenden möglicherweise eine große Menge an CPU, die basierend auf der Objektcache wie groß geworden ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-969">Certain operations, such as Add, Remove, Find, Entry and SaveChanges, trigger calls to DetectChanges which might consume a large amount of CPU based on how large the object cache has become.</span></span> <span data-ttu-id="6cfbd-970">Der Grund dafür ist, dass Objektcache und das Objekt Status-Manager, versuchen Sie, als bleiben synchronisiert werden, wie möglich auf jeden Vorgang, der an einen Kontext durchgeführt werden, sodass die erzeugten Daten garantiert ist, unter einer Vielzahl von Szenarien korrekt zu sein.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-970">The reason for this is that the object cache and the object state manager try to stay as synchronized as possible on each operation performed to a context so that the produced data is guaranteed to be correct under a wide array of scenarios.</span></span>

<span data-ttu-id="6cfbd-971">Es ist im Allgemeinen empfohlen, automatische änderungserkennung für Entity Framework für die gesamte Lebensdauer der Anwendung aktiviert zu lassen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-971">It is generally a good practice to leave Entity Framework’s automatic change detection enabled for the entire life of your application.</span></span> <span data-ttu-id="6cfbd-972">Wenn Ihr Szenario durch hohe CPU-Auslastung negativ beeinflusst wird wird, und Ihre Profile anzugeben, dass die Ursache der Aufruf von DetectChanges, beachten Sie, vorübergehend AutoDetectChanges im sensiblen Bereich Ihres Codes deaktivieren:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-972">If your scenario is being negatively affected by high CPU usage and your profiles indicate that the culprit is the call to DetectChanges, consider temporarily turning off AutoDetectChanges in the sensitive portion of your code:</span></span>

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

<span data-ttu-id="6cfbd-973">Vor einem ausschalten AutoDetectChanges durch, ist es gut zu wissen, dass dies möglicherweise dazu, dass Entity Framework, verlieren die Möglichkeit, bestimmte Informationen zu den Änderungen zu verfolgen, die für die Entitäten durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-973">Before turning off AutoDetectChanges, it’s good to understand that this might cause Entity Framework to lose its ability to track certain information about the changes that are taking place on the entities.</span></span> <span data-ttu-id="6cfbd-974">Wenn nicht ordnungsgemäß verarbeitet, kann dies Dateninkonsistenz in Ihrer Anwendung führen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-974">If handled incorrectly, this might cause data inconsistency on your application.</span></span> <span data-ttu-id="6cfbd-975">Finden Sie weitere Informationen zum Deaktivieren der AutoDetectChanges, \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-975">For more information on turning off AutoDetectChanges, read \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span></span>

### <a name="93------context-per-request"></a><span data-ttu-id="6cfbd-976">9.3 Kontext pro Anforderung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-976">9.3      Context per request</span></span>

<span data-ttu-id="6cfbd-977">Entitätsframework-Kontexte sollen verwendet werden, da es sich bei Auftreten von kurzlebige-Instanzen verwendet, um die optimale Leistung zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-977">Entity Framework’s contexts are meant to be used as short-lived instances in order to provide the most optimal performance experience.</span></span> <span data-ttu-id="6cfbd-978">Kontexte sind erwartungsgemäß von kurzer kurzlebig und verworfen, und daher sehr einfache und Metadaten, die möglichst reutilize implementiert wurden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-978">Contexts are expected to be short lived and discarded, and as such have been implemented to be very lightweight and reutilize metadata whenever possible.</span></span> <span data-ttu-id="6cfbd-979">-Szenarien ist es wichtig zu beachten Sie, dass keinen Kontext für mehr als die Dauer einer einzelnen Anforderung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-979">In web scenarios it’s important to keep this in mind and not have a context for more than the duration of a single request.</span></span> <span data-ttu-id="6cfbd-980">Auf ähnliche Weise sollte in nicht-Szenarien Kontext basierend auf Ihre Kenntnisse zu den verschiedenen Ebenen des Zwischenspeicherns im Entity Framework verworfen werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-980">Similarly, in non-web scenarios, context should be discarded based on your understanding of the different levels of caching in the Entity Framework.</span></span> <span data-ttu-id="6cfbd-981">Im Allgemeinen sollte eine vermeiden, dass eine Kontextinstanz während der gesamten Lebensdauer der Anwendung als auch Kontexte pro Thread und statischen Kontext werden können.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-981">Generally speaking, one should avoid having a context instance throughout the life of the application, as well as contexts per thread and static contexts.</span></span>

### <a name="94------database-null-semantics"></a><span data-ttu-id="6cfbd-982">9.4-Datenbank-null-Semantik</span><span class="sxs-lookup"><span data-stu-id="6cfbd-982">9.4      Database null semantics</span></span>

<span data-ttu-id="6cfbd-983">Entitätsframework standardmäßig generiert die SQL-Code mit C\# null-Vergleichssemantik.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-983">Entity Framework by default will generate SQL code that has C\# null comparison semantics.</span></span> <span data-ttu-id="6cfbd-984">Beachten Sie die folgende Beispielabfrage:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-984">Consider the following example query:</span></span>

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

<span data-ttu-id="6cfbd-985">In diesem Beispiel haben wir eine Anzahl von nullable-Variablen auf NULL festlegbaren Eigenschaften für die Entität, z. B. SupplierID "und" UnitPrice vergleichen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-985">In this example, we’re comparing a number of nullable variables against nullable properties on the entity, such as SupplierID and UnitPrice.</span></span> <span data-ttu-id="6cfbd-986">Das generierte SQL für diese Abfrage fordert, wenn der Wert des Parameters den Wert der Spalte identisch ist oder wenn die Parameter und die Werte der Spalte null sind.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-986">The generated SQL for this query will ask if the parameter value is the same as the column value, or if both the parameter and the column values are null.</span></span> <span data-ttu-id="6cfbd-987">Dies wird ausgeblendet, wie die Datenbank-Server NULL-Werte behandelt, und stellt eine konsistente C\# Erfahrung über verschiedene Datenbankanbieter null.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-987">This will hide the way the database server handles nulls and will provide a consistent C\# null experience across different database vendors.</span></span> <span data-ttu-id="6cfbd-988">Auf der anderen Seite der generierte Code ist ein wenig kompliziert, und kann nicht ausgeführt werden, auch bei den Betrag der Vergleiche in der Where-Anweisung der Abfrage eine große Anzahl erreicht.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-988">On the other hand, the generated code is a bit convoluted and may not perform well when the amount of comparisons in the where statement of the query grows to a large number.</span></span>

<span data-ttu-id="6cfbd-989">Eine Möglichkeit, dieser Situation ist die Verwendung von Datenbank-null-Semantik.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-989">One way to deal with this situation is by using database null semantics.</span></span> <span data-ttu-id="6cfbd-990">Beachten Sie, die dies für den C-möglicherweise unterschiedlich Verhalten möglicherweise\# null-Semantik, da jetzt Entity Framework einfacheres SQL, die die Methode verfügbar macht generiert, die Datenbank-Engine null-Werte behandelt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-990">Note that this might potentially behave differently to the C\# null semantics since now Entity Framework will generate simpler SQL that exposes the way the database engine handles null values.</span></span> <span data-ttu-id="6cfbd-991">Datenbank-null-Semantik kann pro kontextbezogen mit einer einzelnen Konfigurationszeile mit der Kontext aktiviert sein:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-991">Database null semantics can be activated per-context with one single configuration line against the context configuration:</span></span>

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

<span data-ttu-id="6cfbd-992">Kleine bis mittlere Größe Abfragen zeigt keine leistungsverbesserung der wahrnehmbaren bei Verwendung von Datenbank-null-Semantik, aber der Unterschied wird umso deutlicher, für Abfragen mit einer großen Anzahl von möglichen null-Vergleiche.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-992">Small to medium sized queries will not display a perceptible performance improvement when using database null semantics, but the difference will become more noticeable on queries with a large number of potential null comparisons.</span></span>

<span data-ttu-id="6cfbd-993">In der Beispielabfrage, die oben genannten war der Leistungsunterschied weniger als 2 % in einer Microbenchmark in einer kontrollierten Umgebung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-993">In the example query above, the performance difference was less than 2% in a microbenchmark running in a controlled environment.</span></span>

### <a name="95------async"></a><span data-ttu-id="6cfbd-994">9.5 Async</span><span class="sxs-lookup"><span data-stu-id="6cfbd-994">9.5      Async</span></span>

<span data-ttu-id="6cfbd-995">Entity Framework 6 eingeführte Unterstützung von asynchronen Vorgängen bei der Ausführung unter .NET 4.5 oder höher.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-995">Entity Framework 6 introduced support of async operations when running on .NET 4.5 or later.</span></span> <span data-ttu-id="6cfbd-996">Zum größten Teil, der Anwendungen, die e/a Konflikte verknüpft werden, profitieren am meisten von der asynchronen Abfrage mithilfe und Speichervorgängen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-996">For the most part, applications that have IO related contention will benefit the most from using asynchronous query and save operations.</span></span> <span data-ttu-id="6cfbd-997">Wenn Ihre Anwendung von e/a-Konflikte nicht der Fall ist, wird die Verwendung von Async im besten Fall wird synchron ausgeführt und geben das Ergebnis zurück, in die gleiche Menge an Zeit wie ein synchroner Aufruf oder im schlimmsten Fall einfach verzögern der Ausführung einer asynchronen Aufgabe und Hinzufügen von zusätzlichen tim e für die Ausführung Ihres Szenarios.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-997">If your application does not suffer from IO contention, the use of async will, in the best cases, run synchronously and return the result in the same amount of time as a synchronous call, or in the worst case, simply defer execution to an asynchronous task and add extra time to the completion of your scenario.</span></span>

<span data-ttu-id="6cfbd-998">Informationen zu asynchroner Programmierung Arbeit, die helfen, die Sie die Entscheidung, ob Async die Leistung Ihrer Anwendung verbessert besuchen [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-998">For information on how asynchronous programming work that will help you deciding if async will improve the performance of your application visit [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span></span> <span data-ttu-id="6cfbd-999">Weitere Informationen zur Verwendung von asynchronen Vorgängen auf Entity Framework finden Sie unter [asynchronen Abfrage- und speichern](~/ef6/fundamentals/async.md
).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-999">For more information on the use of async operations on Entity Framework, see [Async Query and Save](~/ef6/fundamentals/async.md
).</span></span>

### <a name="96------ngen"></a><span data-ttu-id="6cfbd-1000">9.6 NGEN</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1000">9.6      NGEN</span></span>

<span data-ttu-id="6cfbd-1001">Entitätsframework 6 stammt nicht in der Standardinstallation von .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1001">Entity Framework 6 does not come in the default installation of .NET framework.</span></span> <span data-ttu-id="6cfbd-1002">Daher sind die Entity Framework-Assemblys nicht, dass NGEN standardmäßig würde, was bedeutet, dass alle der Entity Framework-Code gelten die gleichen JIT'ing Kosten als jede andere MSIL-Assembly ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1002">As such, the Entity Framework assemblies are not NGEN’d by default which means that all the Entity Framework code is subject to the same JIT’ing costs as any other MSIL assembly.</span></span> <span data-ttu-id="6cfbd-1003">Dies kann die F5-Erfahrung beim Entwickeln und auch auf den Kaltstart der Anwendung in die produktionsumgebungen beeinträchtigt werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1003">This might degrade the F5 experience while developing and also the cold startup of your application in the production environments.</span></span> <span data-ttu-id="6cfbd-1004">Um die Senkung der Kosten für CPU und Arbeitsspeicher des JIT'ing ist es ratsam, NGEN-images von Entity Framework nach Bedarf.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1004">In order to reduce the CPU and memory costs of JIT’ing it is advisable to NGEN the Entity Framework images as appropriate.</span></span> <span data-ttu-id="6cfbd-1005">Weitere Informationen zum Verbessern der startleistung von Entity Framework 6 mit NGEN finden Sie unter [Verbessern der Startleistung mit NGen](~/ef6/fundamentals/performance/ngen.md).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1005">For more information on how to improve the startup performance of Entity Framework 6 with NGEN, see [Improving Startup Performance with NGen](~/ef6/fundamentals/performance/ngen.md).</span></span>

### <a name="97------code-first-versus-edmx"></a><span data-ttu-id="6cfbd-1006">9.7 code First und EDMX-Datei</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1006">9.7      Code First versus EDMX</span></span>

<span data-ttu-id="6cfbd-1007">Entity Framework Gründen über die Impedance-Mismatch-Problems zwischen objektorientierter Programmierung und relationalen Datenbanken, indem Sie eine in-Memory-Darstellung des konzeptionellen Modell (die Objekte), das Speicherschema (Datenbank) und eine Zuordnung zwischen den zwei.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1007">Entity Framework reasons about the impedance mismatch problem between object oriented programming and relational databases by having an in-memory representation of the conceptual model (the objects), the storage schema (the database) and a mapping between the two.</span></span> <span data-ttu-id="6cfbd-1008">Diese Metadaten ist ein Entity Data Model oder EDM kurz bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1008">This metadata is called an Entity Data Model, or EDM for short.</span></span> <span data-ttu-id="6cfbd-1009">Aus diesem EDM Entity Framework die Objekte im Arbeitsspeicher der Datenbank die Ansichten auf Roundtrip Daten abgeleitet und sichern.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1009">From this EDM, Entity Framework will derive the views to roundtrip data from the objects in memory to the database and back.</span></span>

<span data-ttu-id="6cfbd-1010">Das konzeptionelle Modell, das Speicherschema und die Zuordnung gibt Wenn Entity Framework, früher mit einer EDMX-Datei verwendet wird, dann die Modell laden Phase nur verfügt über zu überprüfen, ob das EDM richtig (z. B. Stellen Sie sicher, dass keine Zuordnungen nicht vorhanden sind), klicken Sie dann Generieren Sie die Ansichten zu, überprüfen Sie die Ansichten und haben Sie diese Metadaten, die zur Verwendung bereit.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1010">When Entity Framework is used with an EDMX file that formally specifies the conceptual model, the storage schema, and the mapping, then the model loading stage only has to validate that the EDM is correct (for example, make sure that no mappings are missing), then generate the views, then validate the views and have this metadata ready for use.</span></span> <span data-ttu-id="6cfbd-1011">Nur dann kann eine Abfrage ausgeführt werden, oder neue Daten im Datenspeicher gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1011">Only then can a query be executed or new data be saved to the data store.</span></span>

<span data-ttu-id="6cfbd-1012">Der Code First-Ansatz ist im Grunde eine anspruchsvolle Entity Data Model-Generator.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1012">The Code First approach is, at its heart, a sophisticated Entity Data Model generator.</span></span> <span data-ttu-id="6cfbd-1013">Das Entity Framework verfügt über ein EDM aus den bereitgestellten Code zu erstellen; Dies erfolgt durch die Klassen, die das Modell, Anwenden von Konventionen, und konfigurieren das Modell über die Fluent-API zum Analysieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1013">The Entity Framework has to produce an EDM from the provided code; it does so by analyzing the classes involved in the model, applying conventions and configuring the model via the Fluent API.</span></span> <span data-ttu-id="6cfbd-1014">Nachdem das EDM erstellt wurde, verhält sich das Entity Framework im Wesentlichen Weise, wie würden sie hatte, eine EDMX-Datei wurde im Projekt vorhanden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1014">After the EDM is built, the Entity Framework essentially behaves the same way as it would had an EDMX file been present in the project.</span></span> <span data-ttu-id="6cfbd-1015">Auf diese Weise bietet beim Erstellen des Modells aus Code First zusätzlichen Komplexität, der in eine langsamere Startzeit für das Entity Framework, dass eine EDMX-Datei im Vergleich zu übersetzt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1015">Thus, building the model from Code First adds extra complexity that translates into a slower startup time for the Entity Framework when compared to having an EDMX.</span></span> <span data-ttu-id="6cfbd-1016">Die Kosten sind völlig abhängig von der Größe und Komplexität des Modells, das erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1016">The cost is completely dependent on the size and complexity of the model that’s being built.</span></span>

<span data-ttu-id="6cfbd-1017">Bei der Auswahl EDMX-Datei im Vergleich zu Code First verwenden, ist es wichtig zu wissen, dass die Flexibilität, die durch Code First eingeführt, die Kosten für das Erstellen des Modells zum ersten Mal erhöht.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1017">When choosing to use EDMX versus Code First, it’s important to know that the flexibility introduced by Code First increases the cost of building the model for the first time.</span></span> <span data-ttu-id="6cfbd-1018">Wenn Ihre Anwendung gegen die Kosten für diese ersten Last widerstandsfähig in der Regel werden Code First die bevorzugte Methode zu.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1018">If your application can withstand the cost of this first-time load then typically Code First will be the preferred way to go.</span></span>

## <a name="10-investigating-performance"></a><span data-ttu-id="6cfbd-1019">10 Untersuchen der Leistung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1019">10 Investigating Performance</span></span>

### <a name="101-using-the-visual-studio-profiler"></a><span data-ttu-id="6cfbd-1020">10.1 mithilfe der Visual Studio-Profiler</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1020">10.1 Using the Visual Studio Profiler</span></span>

<span data-ttu-id="6cfbd-1021">Wenn Sie Leistungsprobleme mit Entity Framework haben, können Sie einen Profiler, wie in Visual Studio integriert verwenden, um anzuzeigen, in denen Ihre Anwendung Zeit verloren geht.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1021">If you are having performance issues with the Entity Framework, you can use a profiler like the one built into Visual Studio to see where your application is spending its time.</span></span> <span data-ttu-id="6cfbd-1022">Dies ist das Tool, das wir verwendet, um die Kreisdiagramme im Blogbeitrag "Exploring the Performance of ADO.NET Entity Framework - Teil 1" zu generieren ( \<http://blogs.msdn.com/b/adonet/archive/2008/02/04/exploring-the-performance-of-the-ado-net-entity-framework-part-1.aspx>) , die anzeigen, in denen Entity Framework bei Abfragen für kalte und warme befindet.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1022">This is the tool we used to generate the pie charts in the “Exploring the Performance of the ADO.NET Entity Framework - Part 1” blog post ( \<http://blogs.msdn.com/b/adonet/archive/2008/02/04/exploring-the-performance-of-the-ado-net-entity-framework-part-1.aspx>) that show where Entity Framework spends its time during cold and warm queries.</span></span>

<span data-ttu-id="6cfbd-1023">"Profilerstellung Entitätsframework, die mithilfe der Visual Studio 2010-Profiler" im Blogbeitrag von Daten und Modellieren von Customer Advisory Team geschrieben wurde, zeigt ein praktisches Beispiel, wie sie den Profiler verwendet, um ein Leistungsproblem zu untersuchen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1023">The "Profiling Entity Framework using the Visual Studio 2010 Profiler" blog post written by the Data and Modeling Customer Advisory Team shows a real-world example of how they used the profiler to investigate a performance problem.</span></span>  <span data-ttu-id="6cfbd-1024">\<http://blogs.msdn.com/b/dmcat/archive/2010/04/30/profiling-entity-framework-using-the-visual-studio-2010-profiler.aspx>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1024">\<http://blogs.msdn.com/b/dmcat/archive/2010/04/30/profiling-entity-framework-using-the-visual-studio-2010-profiler.aspx>.</span></span> <span data-ttu-id="6cfbd-1025">Dieser Beitrag wurde für eine Windows-Anwendung geschrieben.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1025">This post was written for a windows application.</span></span> <span data-ttu-id="6cfbd-1026">Wenn Sie ein Profil eine Webanwendung müssen funktionieren die Tools Windows Performance Recorder (WPR) und Windows Performance Analyzer (WPA) eine bessere Leistung als die Verwendung von Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1026">If you need to profile a web application the Windows Performance Recorder (WPR) and Windows Performance Analyzer (WPA) tools may work better than working from Visual Studio.</span></span> <span data-ttu-id="6cfbd-1027">WPR "und" WPA sind Teil der Windows Performance Toolkit, das in das Windows Assessment and Deployment Kit enthalten ist ( [http://www.microsoft.com/en-US/download/details.aspx?id=39982](https://www.microsoft.com/en-US/download/details.aspx?id=39982)).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1027">WPR and WPA are part of the Windows Performance Toolkit which is included with the Windows Assessment and Deployment Kit ( [http://www.microsoft.com/en-US/download/details.aspx?id=39982](https://www.microsoft.com/en-US/download/details.aspx?id=39982)).</span></span>

### <a name="102-applicationdatabase-profiling"></a><span data-ttu-id="6cfbd-1028">10.2 Anwendung/Datenbank-profilerstellung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1028">10.2 Application/Database profiling</span></span>

<span data-ttu-id="6cfbd-1029">Tools wie der Profiler in Visual Studio integriert erfahren Sie, wo Ihre Anwendung Zeit verbringt, ist.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1029">Tools like the profiler built into Visual Studio tell you where your application is spending time.</span></span>  <span data-ttu-id="6cfbd-1030">Eine andere Art von Profiler ist verfügbar, die dynamische Analyse der ausgeführten Anwendung, entweder in der Produktion oder vor der Produktion je nach Anforderungen und sucht nach häufige Fehlerquellen und Anti-Muster der Zugriff auf die Datenbank.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1030">Another type of profiler is available that performs dynamic analysis of your running application, either in production or pre-production depending on needs, and looks for common pitfalls and anti-patterns of database access.</span></span>

<span data-ttu-id="6cfbd-1031">Zwei kommerziell erhältliche Tools für die profilerstellung werden die Entity Framework Profiler ( \<http://efprof.com>) und ORMProfiler ( \<http://ormprofiler.com>).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1031">Two commercially available profilers are the Entity Framework Profiler ( \<http://efprof.com>) and ORMProfiler ( \<http://ormprofiler.com>).</span></span>

<span data-ttu-id="6cfbd-1032">Wenn Ihre Anwendung eine MVC-Anwendung mithilfe von Code First ist, können Sie StackExchanges-MiniProfiler verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1032">If your application is an MVC application using Code First, you can use StackExchange's MiniProfiler.</span></span> <span data-ttu-id="6cfbd-1033">Scott Hanselman beschreibt dieses Tool, das in seinem Blog unter: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1033">Scott Hanselman describes this tool in his blog at: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span></span>

<span data-ttu-id="6cfbd-1034">Weitere Informationen zur profilerstellung Ihrer Anwendung Datenbankaktivität, Julie lermans MSDN Magazine-Artikel, finden Sie unter [Datenbankaktivitäten im Entity Framework-Profilerstellung](https://msdn.microsoft.com/magazine/gg490349.aspx).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1034">For more information on profiling your application's database activity, see Julie Lerman's MSDN Magazine article titled [Profiling Database Activity in the Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span></span>

### <a name="103-database-logger"></a><span data-ttu-id="6cfbd-1035">10.3-Datenbank-Protokollierung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1035">10.3 Database logger</span></span>

<span data-ttu-id="6cfbd-1036">Bei Verwendung von Entity Framework 6 auch sollten Sie mithilfe der integrierten Protokollierung-Funktion.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1036">If you are using Entity Framework 6 also consider using the built-in logging functionality.</span></span> <span data-ttu-id="6cfbd-1037">Die Datenbank-Eigenschaft des Kontexts kann angewiesen werden, um die Aktivität über eine einfache einzeilige-Konfiguration zu protokollieren:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1037">The Database property of the context can be instructed to log its activity via a simple one-line configuration:</span></span>

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

<span data-ttu-id="6cfbd-1038">In diesem Beispiel wird die Aktivität "Datenbank" in der Konsole protokolliert werden, aber die Log-Eigenschaft kann konfiguriert werden, um eine Aktion aufzurufen&lt;Zeichenfolge&gt; delegieren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1038">In this example the database activity will be logged to the console, but the Log property can be configured to call any Action&lt;string&gt; delegate.</span></span>

<span data-ttu-id="6cfbd-1039">Wenn Sie aktivieren möchten datenbankprotokollierung ohne neu kompilieren zu müssen, und Sie werden mithilfe von Entity Framework 6.1 oder höher, Sie können dies vornehmen, sofern einen Interceptor in der Datei "Web.config" oder "App.config" Ihrer Anwendung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1039">If you want to enable database logging without recompiling, and you are using Entity Framework 6.1 or later, you can do so by adding an interceptor in the web.config or app.config file of your application.</span></span>

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

<span data-ttu-id="6cfbd-1040">Weitere Informationen dazu, wie Protokollierung hinzufügen, ohne erneute Kompilierung wechseln Sie zu \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1040">For more information on how to add logging without recompiling go to \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span></span>

## <a name="11-appendix"></a><span data-ttu-id="6cfbd-1041">11 Anhang</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1041">11 Appendix</span></span>

### <a name="111-a-test-environment"></a><span data-ttu-id="6cfbd-1042">11.1 a Test-Umgebung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1042">11.1 A. Test Environment</span></span>

<span data-ttu-id="6cfbd-1043">Diese Umgebung verwendet einen 2-Machine-Setup mit der Datenbank auf einem separaten Computer von der Clientanwendung.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1043">This environment uses a 2-machine setup with the database on a separate machine from the client application.</span></span> <span data-ttu-id="6cfbd-1044">Computer sind im selben Rack, also die Netzwerklatenz relativ gering, aber realistischer als eine Umgebung für die einzelnen Computer.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1044">Machines are in the same rack, so network latency is relatively low, but more realistic than a single-machine environment.</span></span>

#### <a name="1111-------app-server"></a><span data-ttu-id="6cfbd-1045">11.1.1-app-Server</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1045">11.1.1       App Server</span></span>

##### <a name="11111------software-environment"></a><span data-ttu-id="6cfbd-1046">11.1.1.1-Software-Umgebung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1046">11.1.1.1      Software Environment</span></span>

-   <span data-ttu-id="6cfbd-1047">Entity Framework 4-Software-Umgebung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1047">Entity Framework 4 Software Environment</span></span>
    -   <span data-ttu-id="6cfbd-1048">Name des Betriebssystems: Windows Server 2008 R2 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1048">OS Name: Windows Server 2008 R2 Enterprise SP1.</span></span>
    -   <span data-ttu-id="6cfbd-1049">Visual Studio 2010 – Ultimate.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1049">Visual Studio 2010 – Ultimate.</span></span>
    -   <span data-ttu-id="6cfbd-1050">Visual Studio 2010 SP1 (nur für einige Vergleiche).</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1050">Visual Studio 2010 SP1 (only for some comparisons).</span></span>
-   <span data-ttu-id="6cfbd-1051">Entity Framework 5 und 6-Software-Umgebung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1051">Entity Framework 5 and 6 Software Environment</span></span>
    -   <span data-ttu-id="6cfbd-1052">Name des Betriebssystems: Windows 8.1 Enterprise</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1052">OS Name: Windows 8.1 Enterprise</span></span>
    -   <span data-ttu-id="6cfbd-1053">Visual Studio 2013 – Ultimate.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1053">Visual Studio 2013 – Ultimate.</span></span>

##### <a name="11112------hardware-environment"></a><span data-ttu-id="6cfbd-1054">11.1.1.2 Hardwareumgebung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1054">11.1.1.2      Hardware Environment</span></span>

-   <span data-ttu-id="6cfbd-1055">Dual-Prozessor: Intel(R) Xeon(R) CPU L5520 W3530 @ mit 2,27 GHz, 2261 Mhz8 GHz, 4 Kerne, 84 logische Prozessoren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1055">Dual Processor:     Intel(R) Xeon(R) CPU L5520 W3530 @ 2.27GHz, 2261 Mhz8 GHz, 4 Core(s), 84 Logical Processor(s).</span></span>
-   <span data-ttu-id="6cfbd-1056">2412 GB RamRAM.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1056">2412 GB RamRAM.</span></span>
-   <span data-ttu-id="6cfbd-1057">136 GB SCSI250GB SATA 7200 u/Min / 3GB/s-Laufwerk in 4 Partitionen aufgeteilt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1057">136 GB SCSI250GB SATA 7200 rpm 3GB/s drive split into 4 partitions.</span></span>

#### <a name="1112-------db-server"></a><span data-ttu-id="6cfbd-1058">11.1.2-DB-server</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1058">11.1.2       DB server</span></span>

##### <a name="11121------software-environment"></a><span data-ttu-id="6cfbd-1059">11.1.2.1-Software-Umgebung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1059">11.1.2.1      Software Environment</span></span>

-   <span data-ttu-id="6cfbd-1060">Name des Betriebssystems: Windows Server 2008 R28.1 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1060">OS Name: Windows Server 2008 R28.1 Enterprise SP1.</span></span>
-   <span data-ttu-id="6cfbd-1061">SQL Server 2008 R22012.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1061">SQL Server 2008 R22012.</span></span>

##### <a name="11122------hardware-environment"></a><span data-ttu-id="6cfbd-1062">11.1.2.2 Hardwareumgebung</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1062">11.1.2.2      Hardware Environment</span></span>

-   <span data-ttu-id="6cfbd-1063">Einzelner Prozessor: Intel(R) Xeon(R) CPU L5520 mit 2,27 GHz, 2261 MhzES-1620 0 @ 3.60 GHz, 4 Kerne, 8 logische Prozessoren.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1063">Single Processor: Intel(R) Xeon(R) CPU L5520  @ 2.27GHz, 2261 MhzES-1620 0 @ 3.60GHz, 4 Core(s), 8 Logical Processor(s).</span></span>
-   <span data-ttu-id="6cfbd-1064">824 GB RamRAM.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1064">824 GB RamRAM.</span></span>
-   <span data-ttu-id="6cfbd-1065">465 GB ATA500GB SATA 7200 Rpm 6 GBIT/s-Laufwerk in 4 Partitionen aufgeteilt.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1065">465 GB ATA500GB SATA 7200 rpm 6GB/s drive split into 4 partitions.</span></span>

### <a name="112------b-query-performance-comparison-tests"></a><span data-ttu-id="6cfbd-1066">11.2 b Abfrage Leistung im Vergleich tests</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1066">11.2      B. Query performance comparison tests</span></span>

<span data-ttu-id="6cfbd-1067">Das Northwind-Modell wurde verwendet, um diese Tests auszuführen.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1067">The Northwind model was used to execute these tests.</span></span> <span data-ttu-id="6cfbd-1068">Es wurde aus der Datenbank, die mit dem Entity Framework Designer generiert.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1068">It was generated from the database using the Entity Framework designer.</span></span> <span data-ttu-id="6cfbd-1069">Klicken Sie dann wurde der folgende Code verwendet, um die Leistung von Optionen für die Abfrage vergleichen:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1069">Then, the following code was used to compare the performance of the query execution options:</span></span>

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a><span data-ttu-id="6cfbd-1070">11.3 C. Navision Modell</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1070">11.3 C. Navision Model</span></span>

<span data-ttu-id="6cfbd-1071">Die Navision-Datenbank ist eine große Datenbank verwendet, um die Demo Microsoft Dynamics-NAV.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1071">The Navision database is a large database used to demo Microsoft Dynamics – NAV.</span></span> <span data-ttu-id="6cfbd-1072">Die generierte konzeptionelle Modell enthält 1005 Entitätenmengen und Zuordnungssätze 4227.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1072">The generated conceptual model contains 1005 entity sets and 4227 association sets.</span></span> <span data-ttu-id="6cfbd-1073">Das Modell im Test verwendeten "flach" – ist verfügt über keine Vererbung hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1073">The model used in the test is “flat” – no inheritance has been added to it.</span></span>

#### <a name="1131-queries-used-for-navision-tests"></a><span data-ttu-id="6cfbd-1074">11.3.1 Abfragen für die Navision tests</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1074">11.3.1 Queries used for Navision tests</span></span>

<span data-ttu-id="6cfbd-1075">Die Liste der Abfragen verwendet, mit dem Modell Navision enthält 3 Kategorien von Entity SQL-Abfragen:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1075">The queries list used with the Navision model contains 3 categories of Entity SQL queries:</span></span>

##### <a name="11311-lookup"></a><span data-ttu-id="6cfbd-1076">11.3.1.1-Suche</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1076">11.3.1.1 Lookup</span></span>

<span data-ttu-id="6cfbd-1077">Eine einfache Suchabfrage ohne Aggregationen</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1077">A simple lookup query with no aggregations</span></span>

-   <span data-ttu-id="6cfbd-1078">Anzahl: 16232</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1078">Count: 16232</span></span>
-   <span data-ttu-id="6cfbd-1079">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1079">Example:</span></span>

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312-singleaggregating"></a><span data-ttu-id="6cfbd-1080">11.3.1.2 SingleAggregating</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1080">11.3.1.2 SingleAggregating</span></span>

<span data-ttu-id="6cfbd-1081">Eine normale BI-Abfrage mit mehrere Aggregationen, jedoch keine Teilergebnisse (Einzelabfrage)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1081">A normal BI query with multiple aggregations, but no subtotals (single query)</span></span>

-   <span data-ttu-id="6cfbd-1082">Anzahl: 2313</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1082">Count: 2313</span></span>
-   <span data-ttu-id="6cfbd-1083">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1083">Example:</span></span>

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

<span data-ttu-id="6cfbd-1084">In denen MDF\_SessionLogin\_Zeit\_Max() in das Modell definiert ist:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1084">Where MDF\_SessionLogin\_Time\_Max() is defined in the model as:</span></span>

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313-aggregatingsubtotals"></a><span data-ttu-id="6cfbd-1085">11.3.1.3 AggregatingSubtotals</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1085">11.3.1.3 AggregatingSubtotals</span></span>

<span data-ttu-id="6cfbd-1086">Eine BI-Abfrage mit Aggregationen und Teilergebnisse (über die Union aller)</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1086">A BI query with aggregations and subtotals (via union all)</span></span>

-   <span data-ttu-id="6cfbd-1087">Anzahl: 178</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1087">Count: 178</span></span>
-   <span data-ttu-id="6cfbd-1088">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="6cfbd-1088">Example:</span></span>

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
