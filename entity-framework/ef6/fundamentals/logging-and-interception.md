---
title: Protokollierung und Abfangen von Datenbankvorgängen - EF6
author: divega
ms.date: 2016-10-23
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
ms.openlocfilehash: 9a8be81af45d9f27caa8c26f66d219dc568b6604
ms.sourcegitcommit: 0d36e8ff0892b7f034b765b15e041f375f88579a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/09/2018
ms.locfileid: "44251270"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="5f194-102">Protokollierung und Abfangen von Datenbankvorgängen</span><span class="sxs-lookup"><span data-stu-id="5f194-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="5f194-103">**Nur EF6 und höher:** Die Features, APIs usw., die auf dieser Seite erläutert werden, wurden in Entity Framework 6 eingeführt.</span><span class="sxs-lookup"><span data-stu-id="5f194-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="5f194-104">Wenn Sie eine frühere Version verwenden, gelten manche Informationen nicht.</span><span class="sxs-lookup"><span data-stu-id="5f194-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="5f194-105">Ab Entity Framework 6, jedes Mal, wenn Entity Framework einem Befehl an der Datenbank mit diesem Befehl sendet, kann vom Anwendungscode abgefangen werden.</span><span class="sxs-lookup"><span data-stu-id="5f194-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="5f194-106">Dies wird am häufigsten für die Protokollierung von SQL verwendet, aber es kann auch verwendet werden, um zu ändern, oder brechen Sie den Befehl.</span><span class="sxs-lookup"><span data-stu-id="5f194-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="5f194-107">Sie enthält insbesondere EF:</span><span class="sxs-lookup"><span data-stu-id="5f194-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="5f194-108">Eine Log-Eigenschaft für den Kontext, der ähnlich wie DataContext.Log in LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="5f194-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="5f194-109">Ein Mechanismus zum Anpassen der Inhalt und die Formatierung der Ausgabe in das Anwendungsprotokoll gesendet</span><span class="sxs-lookup"><span data-stu-id="5f194-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="5f194-110">Low-Level-Bausteine für die Abfangfunktion sind so flexibler-Steuerelement</span><span class="sxs-lookup"><span data-stu-id="5f194-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="5f194-111">Kontext-Log-Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="5f194-111">Context Log property</span></span>  

<span data-ttu-id="5f194-112">In einen Delegaten für eine beliebige Methode, die eine Zeichenfolge akzeptiert, kann die DbContext.Database.Log-Eigenschaft festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="5f194-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="5f194-113">Es ist am häufigsten mit jeder TextWriter verwendet, auf die "Write"-Methode von diesem TextWriter festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="5f194-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="5f194-114">Alle nach dem aktuellen Kontext generiert SQL werden in der sich der Writer protokolliert.</span><span class="sxs-lookup"><span data-stu-id="5f194-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="5f194-115">Beispielsweise wird der folgende Code SQL an der Konsole protokolliert:</span><span class="sxs-lookup"><span data-stu-id="5f194-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="5f194-116">Beachten Sie, dass dieses Kontexts. Console.Write ist "Database.log" festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5f194-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="5f194-117">Dies ist alles, die was erforderlich ist, um SQL an der Konsole protokolliert.</span><span class="sxs-lookup"><span data-stu-id="5f194-117">This is all that is needed to log SQL to the console.</span></span>  

<span data-ttu-id="5f194-118">Fügen Sie einige einfachen Code für die Abfrage/einfügen/aktualisieren, damit wir eine Ausgabe angezeigt werden:</span><span class="sxs-lookup"><span data-stu-id="5f194-118">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="5f194-119">Dadurch wird die folgende Ausgabe generiert:</span><span class="sxs-lookup"><span data-stu-id="5f194-119">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="5f194-120">(Beachten Sie, dass dies ist die Ausgabe, vorausgesetzt, dass es sich bei jeder Initialisierung der Datenbank bereits geschehen ist.</span><span class="sxs-lookup"><span data-stu-id="5f194-120">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="5f194-121">Wenn Datenbankinitialisierung nicht bereits geschehen hatte, und klicken Sie dann wäre hat noch viel mehr Ausgabe, die mit der Arbeit Migrationen im Hintergrund zu überprüfen oder eine neue Datenbank erstellen.)</span><span class="sxs-lookup"><span data-stu-id="5f194-121">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

## <a name="what-gets-logged"></a><span data-ttu-id="5f194-122">Ruft protokolliert?</span><span class="sxs-lookup"><span data-stu-id="5f194-122">What gets logged?</span></span>  

<span data-ttu-id="5f194-123">Wenn der Log-Eigenschaft alle folgenden festgelegt ist, wird die werden protokolliert:</span><span class="sxs-lookup"><span data-stu-id="5f194-123">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="5f194-124">"SQL" für alle anderen Arten von Befehlen.</span><span class="sxs-lookup"><span data-stu-id="5f194-124">SQL for all different kinds of commands.</span></span> <span data-ttu-id="5f194-125">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="5f194-125">For example:</span></span>  
    - <span data-ttu-id="5f194-126">Abfragen, einschließlich der normalen LINQ-Abfragen, eSQL-Abfragen und unformatierte Abfragen von Methoden wie z. B. SqlQuery</span><span class="sxs-lookup"><span data-stu-id="5f194-126">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="5f194-127">Einfügungen, Updates und löschungen, die als Teil von "SaveChanges" generiert</span><span class="sxs-lookup"><span data-stu-id="5f194-127">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="5f194-128">Laden von Abfragen wie die von lazy Loading generierten Beziehung</span><span class="sxs-lookup"><span data-stu-id="5f194-128">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="5f194-129">Parameter</span><span class="sxs-lookup"><span data-stu-id="5f194-129">Parameters</span></span>  
- <span data-ttu-id="5f194-130">Unabhängig davon, ob der Befehl asynchron ausgeführt wird</span><span class="sxs-lookup"><span data-stu-id="5f194-130">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="5f194-131">Ein Zeitstempel, der angibt, wenn der Befehl gestartet ausführen</span><span class="sxs-lookup"><span data-stu-id="5f194-131">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="5f194-132">Unabhängig davon, ob der Befehl erfolgreich abgeschlossen, Fehler durch Auslösen einer Ausnahme oder, für die asynchrone, wurde abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="5f194-132">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="5f194-133">Ein Hinweis auf den Ergebniswert</span><span class="sxs-lookup"><span data-stu-id="5f194-133">Some indication of the result value</span></span>  
- <span data-ttu-id="5f194-134">Die ungefähre Dauer der Zeit zum Ausführen des Befehls dauert.</span><span class="sxs-lookup"><span data-stu-id="5f194-134">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="5f194-135">Beachten Sie, dass dies die Zeit vom Senden des Befehls an das Ergebnisobjekt abrufen.</span><span class="sxs-lookup"><span data-stu-id="5f194-135">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="5f194-136">Es umfasst nicht die Zeit, die Ergebnisse zu lesen.</span><span class="sxs-lookup"><span data-stu-id="5f194-136">It does not include time to read the results.</span></span>  

<span data-ttu-id="5f194-137">Betrachten die Beispielausgabe oben aus, die vier Befehle, die protokolliert werden:</span><span class="sxs-lookup"><span data-stu-id="5f194-137">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="5f194-138">Die Abfrage, die durch den Aufruf von Kontext. Blogs.First</span><span class="sxs-lookup"><span data-stu-id="5f194-138">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="5f194-139">Beachten Sie, dass die ToString-Methode dar, die SQL-Anweisung nicht für diese Abfrage seit gearbeitet haben, würde "First" kein "IQueryable" auf dem ToString aufgerufen werden kann</span><span class="sxs-lookup"><span data-stu-id="5f194-139">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="5f194-140">Die Abfrage aus der Lazy-Blog. Beiträge</span><span class="sxs-lookup"><span data-stu-id="5f194-140">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="5f194-141">Beachten Sie, dass die Details zu den Parametern für den Schlüsselwert für die Lazy Load geschieht.</span><span class="sxs-lookup"><span data-stu-id="5f194-141">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="5f194-142">Nur Eigenschaften des Parameters, die auf nicht standardmäßige Werte festgelegt sind, werden protokolliert.</span><span class="sxs-lookup"><span data-stu-id="5f194-142">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="5f194-143">Beispielsweise wird die Size-Eigenschaft wird nur angezeigt, wenn es ungleich NULL ist.</span><span class="sxs-lookup"><span data-stu-id="5f194-143">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="5f194-144">Zwei Befehle, die sich aus SaveChangesAsync ergeben; eine für die Aktualisierung so ändern Sie einen Post-Titel, die andere für eine Einfügung, einen neuen Beitrag hinzufügen</span><span class="sxs-lookup"><span data-stu-id="5f194-144">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="5f194-145">Beachten Sie, dass die Details zu den Parametern für den Fremdschlüssel "und" Title "</span><span class="sxs-lookup"><span data-stu-id="5f194-145">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="5f194-146">Beachten Sie, dass diese Befehle asynchron ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="5f194-146">Notice that these commands are being executed asynchronously</span></span>  

## <a name="logging-to-different-places"></a><span data-ttu-id="5f194-147">Protokollierung in verschiedenen Speicherorten</span><span class="sxs-lookup"><span data-stu-id="5f194-147">Logging to different places</span></span>  

<span data-ttu-id="5f194-148">Wie oben Protokollierung wird die Konsole sehr leicht.</span><span class="sxs-lookup"><span data-stu-id="5f194-148">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="5f194-149">Es ist auch einfach, melden Sie sich mit verschiedenen Arten, Arbeitsspeicher, Datei usw. der [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span><span class="sxs-lookup"><span data-stu-id="5f194-149">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="5f194-150">Wenn Sie mit LINQ to SQL vertraut sind, die Ihnen, die in LINQ to SQL auffallen, die Log-Eigenschaft auf die tatsächliche TextWriter-Objekt (z. B. Console.Out) beim in EF festgelegt ist, die an eine Methode, die eine Zeichenfolge (z. B. akzeptiert, die Log-Eigenschaft festgelegt ist Console.Write "oder" Console.Out.Write).</span><span class="sxs-lookup"><span data-stu-id="5f194-150">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="5f194-151">Der Grund dafür ist, entkoppeln EF über TextWriter durch das Akzeptieren von jeder Delegat, der als Senke für Zeichenfolgen verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="5f194-151">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="5f194-152">Beispiel: Angenommen, dass Sie bereits einige protokollierungsframework und eine Protokollierungsmethode definiert wie folgt:</span><span class="sxs-lookup"><span data-stu-id="5f194-152">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="5f194-153">Dies kann auf die EF-Log-Eigenschaft wie folgt verknüpft werden:</span><span class="sxs-lookup"><span data-stu-id="5f194-153">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

## <a name="result-logging"></a><span data-ttu-id="5f194-154">Führen Sie die Protokollierung</span><span class="sxs-lookup"><span data-stu-id="5f194-154">Result logging</span></span>  

<span data-ttu-id="5f194-155">Die Protokollierung protokolliert Befehlstext (SQL), Parameter und die Zeile "Wird ausgeführt" mit einem Zeitstempel, bevor der Befehl in die Datenbank gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="5f194-155">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="5f194-156">"Abgeschlossene" Linie, die verstrichene Zeit ist, protokolliert der folgenden Ausführung des Befehls.</span><span class="sxs-lookup"><span data-stu-id="5f194-156">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="5f194-157">Beachten Sie, dass für die asynchrone Befehle die "Abgeschlossene" Zeile nicht angemeldet ist, bis die asynchrone Aufgabe tatsächlich abgeschlossen ist, fehlschlägt oder abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="5f194-157">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="5f194-158">Die Zeile "Abgeschlossene" enthält verschiedene Informationen je nach Art des-Befehls sowie davon, ob die Ausführung erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="5f194-158">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

### <a name="successful-execution"></a><span data-ttu-id="5f194-159">Die erfolgreiche Ausführung</span><span class="sxs-lookup"><span data-stu-id="5f194-159">Successful execution</span></span>  

<span data-ttu-id="5f194-160">Ist für Befehle, die die Ausgabe erfolgreich abgeschlossen "abgeschlossen in x-ms mit Ergebnis:" gefolgt von einigen Überblick darüber, wie das Ergebnis lautet.</span><span class="sxs-lookup"><span data-stu-id="5f194-160">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="5f194-161">Für Befehle, die einen Datenreader das Ergebnis zurückzugeben, ist der Typ des [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="5f194-161">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="5f194-162">Für Befehle, die einen Ganzzahlwert wie das Update zurückgeben ist Befehl das Ergebnis sehen Sie oben, ganze Zahl.</span><span class="sxs-lookup"><span data-stu-id="5f194-162">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

### <a name="failed-execution"></a><span data-ttu-id="5f194-163">Fehler bei der Ausführung</span><span class="sxs-lookup"><span data-stu-id="5f194-163">Failed execution</span></span>  

<span data-ttu-id="5f194-164">Für Befehle, die durch Auslösen einer Ausnahme fehlschlägt, enthält die Ausgabe die Nachricht aus der Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="5f194-164">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="5f194-165">Beispielsweise wird Abfrage für eine Tabelle, die vorhanden ist, SqlQuery mit Ergebnis im Anwendungsprotokoll etwa wie folgt ausgegeben:</span><span class="sxs-lookup"><span data-stu-id="5f194-165">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

### <a name="canceled-execution"></a><span data-ttu-id="5f194-166">Abgebrochene Ausführung</span><span class="sxs-lookup"><span data-stu-id="5f194-166">Canceled execution</span></span>  

<span data-ttu-id="5f194-167">Für asynchrone Befehle, in dem die Aufgabe abgebrochen wird, das Ergebnis möglicherweise Fehler mit einer Ausnahme, da es sich handelt, was der zugrunde liegenden ADO.NET-Anbieter selten der Fall bei dem Versuch zum Abbrechen.</span><span class="sxs-lookup"><span data-stu-id="5f194-167">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="5f194-168">Wenn dies nicht möglich, und die Aufgabe, ordnungsgemäß abgebrochen wird wird die Ausgabe etwa wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="5f194-168">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```  
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="5f194-169">Ändern des Inhalts und Formatierung</span><span class="sxs-lookup"><span data-stu-id="5f194-169">Changing log content and formatting</span></span>  

<span data-ttu-id="5f194-170">Hinter den Kulissen die Eigenschaft "Database.log" Verwenden eines DatabaseLogFormatter-Objekts.</span><span class="sxs-lookup"><span data-stu-id="5f194-170">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="5f194-171">Dieses Objekt bindet effektiv eine IDbCommandInterceptor-Implementierung (siehe unten) an einen Delegaten, der Zeichenfolgen und einen "DbContext" akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="5f194-171">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="5f194-172">Dies bedeutet, dass Methoden auf DatabaseLogFormatter vor und nach der Ausführung von Befehlen von EF aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="5f194-172">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="5f194-173">Diese Methoden DatabaseLogFormatter erfassen und formatieren die Protokollausgabe und an den Delegaten zu senden.</span><span class="sxs-lookup"><span data-stu-id="5f194-173">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="5f194-174">Anpassen von DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="5f194-174">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="5f194-175">Protokolliert werden soll, und die Art der Formatierung ändern kann durch Erstellen einer neuen Klasse, die DatabaseLogFormatter abgeleitet und überschreibt die Methoden entsprechend erreicht werden.</span><span class="sxs-lookup"><span data-stu-id="5f194-175">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="5f194-176">Am häufigsten verwendeten Methoden überschrieben werden:</span><span class="sxs-lookup"><span data-stu-id="5f194-176">The most common methods to override are:</span></span>  

- <span data-ttu-id="5f194-177">LogCommand – überschreiben Sie diese Option, um die ändern, wie Befehle protokolliert werden, bevor sie ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="5f194-177">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="5f194-178">Standardmäßig ruft LogCommand LogParameter für jeden Parameter. Sie können auswählen, in der Außerkraftsetzung oder Parameter stattdessen unterschiedlich behandeln.</span><span class="sxs-lookup"><span data-stu-id="5f194-178">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="5f194-179">LogResult – überschreiben Sie diese Option, um Sie ändern möchten, wie das Ergebnis aus der Ausführung eines Befehls protokolliert wird.</span><span class="sxs-lookup"><span data-stu-id="5f194-179">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="5f194-180">LogParameter – überschreiben Sie diese Option, um die Formatierung und den Inhalt der Parameter-Protokollierung zu ändern.</span><span class="sxs-lookup"><span data-stu-id="5f194-180">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="5f194-181">Nehmen wir beispielsweise an, dass wir nur eine einzelne Zeile anmelden, bevor jeder Befehl in die Datenbank gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="5f194-181">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="5f194-182">Dies kann mit zwei Außerkraftsetzungen erfolgen:</span><span class="sxs-lookup"><span data-stu-id="5f194-182">This can be done with two overrides:</span></span>  

- <span data-ttu-id="5f194-183">Überschreiben Sie LogCommand zum Formatieren und die einzelne SQL-Codezeile zu schreiben</span><span class="sxs-lookup"><span data-stu-id="5f194-183">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="5f194-184">Überschreiben Sie LogResult, um den Vorgang.</span><span class="sxs-lookup"><span data-stu-id="5f194-184">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="5f194-185">Der Code würde in etwa wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="5f194-185">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="5f194-186">Zum Protokollieren Ausgabe rufen einfach die Write-Methode, die Ausgabe an den Delegaten konfigurierten schreiben gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="5f194-186">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="5f194-187">(Beachten Sie, dass dieser Code einfach zum Entfernen von Zeilenumbrüchen nur als Beispiel bewirkt.</span><span class="sxs-lookup"><span data-stu-id="5f194-187">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="5f194-188">Sie wahrscheinlich funktioniert nicht gut für komplexe SQL anzeigen.)</span><span class="sxs-lookup"><span data-stu-id="5f194-188">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="5f194-189">Festlegen der DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="5f194-189">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="5f194-190">Sobald eine neue DatabaseLogFormatter-Klasse, es erstellt wurde muss mit EF registriert werden.</span><span class="sxs-lookup"><span data-stu-id="5f194-190">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="5f194-191">Dies erfolgt mithilfe von codebasierte Konfiguration.</span><span class="sxs-lookup"><span data-stu-id="5f194-191">This is done using code-based configuration.</span></span> <span data-ttu-id="5f194-192">Kurz gesagt bedeutet dies eine neue Klasse erstellen, die "dbconfiguration" in der gleichen Assembly wie die Klasse "DbContext" abgeleitet und dem anschließenden Aufrufen der SetDatabaseLogFormatter im Konstruktor der diese neue Klasse.</span><span class="sxs-lookup"><span data-stu-id="5f194-192">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="5f194-193">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="5f194-193">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="5f194-194">Verwenden die neue DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="5f194-194">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="5f194-195">Diese neue DatabaseLogFormatter wird jetzt verwendet werden, jedes Mal, wenn "Database.log" festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="5f194-195">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="5f194-196">Daher führt das Ausführen des Codes aus Teil 1 jetzt in der folgenden Ausgabe:</span><span class="sxs-lookup"><span data-stu-id="5f194-196">So, running the code from part 1 will now result in the following output:</span></span>  

```  
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="5f194-197">Bausteine für die Abfangfunktion</span><span class="sxs-lookup"><span data-stu-id="5f194-197">Interception building blocks</span></span>  

<span data-ttu-id="5f194-198">Bisher haben wir an, wie DbContext.Database.Log zu verwenden, um das Protokollieren von EF generierten SQL erläutert.</span><span class="sxs-lookup"><span data-stu-id="5f194-198">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="5f194-199">Doch dieser Code ist tatsächlich eine relativ schlanke Fassade, über einige spezielle Bausteine für allgemeinere abfangen.</span><span class="sxs-lookup"><span data-stu-id="5f194-199">But this code is actually a relatively thin façade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="5f194-200">Die Abfangfunktion-Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="5f194-200">Interception interfaces</span></span>  

<span data-ttu-id="5f194-201">Der Abfangfunktion-Code wird das Konzept der Abfangfunktion Schnittstellen erstellt.</span><span class="sxs-lookup"><span data-stu-id="5f194-201">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="5f194-202">Diese Schnittstellen erben von IDbInterceptor und definieren Sie Methoden, die aufgerufen werden, wenn EF eine Aktion ausführt.</span><span class="sxs-lookup"><span data-stu-id="5f194-202">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="5f194-203">Die Absicht besteht darin, eine Schnittstelle pro Typ des abgefangenen Objekts verfügen.</span><span class="sxs-lookup"><span data-stu-id="5f194-203">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="5f194-204">Beispielsweise definiert die Schnittstelle IDbCommandInterceptor Methoden, die aufgerufen werden, bevor EF ExecuteNonQuery, "ExecuteScalar", "ExecuteReader" und zugehörigen Methoden aufruft.</span><span class="sxs-lookup"><span data-stu-id="5f194-204">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="5f194-205">Ebenso definiert die Schnittstelle Methoden, die aufgerufen werden, wenn es sich bei diesen Vorgängen abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5f194-205">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="5f194-206">Die DatabaseLogFormatter-Klasse, der wir uns weiter oben angesehen haben implementiert diese Schnittstelle, um Befehle zu protokollieren.</span><span class="sxs-lookup"><span data-stu-id="5f194-206">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="5f194-207">Der Kontext für die Abfangfunktion</span><span class="sxs-lookup"><span data-stu-id="5f194-207">The interception context</span></span>  

<span data-ttu-id="5f194-208">Betrachten die Methoden, die für jede der Schnittstellen Interceptor definiert es ist offensichtlich, dass für jeden Aufruf wie z. B. DbCommandInterceptionContext angegebenen ein Objekt des Typs DbInterceptionContext oder eine Art von dieser abgeleitet ist\<\>.</span><span class="sxs-lookup"><span data-stu-id="5f194-208">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="5f194-209">Dieses Objekt enthält Kontextinformationen über die Aktion, die EF ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="5f194-209">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="5f194-210">Z. B. wenn die Aktion für einen "DbContext" aufgenommen wird, ist dann "DbContext" in der DbInterceptionContext enthalten.</span><span class="sxs-lookup"><span data-stu-id="5f194-210">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="5f194-211">Auf ähnliche Weise ist für Befehle, die asynchron ausgeführt werden, der IsAsync-Flag auf DbCommandInterceptionContext festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5f194-211">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="5f194-212">Führen Sie die Verarbeitung</span><span class="sxs-lookup"><span data-stu-id="5f194-212">Result handling</span></span>  

<span data-ttu-id="5f194-213">Die DbCommandInterceptionContext\< \> Klasse enthält Eigenschaften, die aufgerufen wird, Ergebnis, OriginalResult, Ausnahme und OriginalException.</span><span class="sxs-lookup"><span data-stu-id="5f194-213">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="5f194-214">Diese Eigenschaften werden festgelegt auf Null/NULL für Aufrufe an den Interceptor-Methoden, die aufgerufen werden, bevor der Vorgang ausgeführt wird, d. h. für die... Ausführen von Methoden.</span><span class="sxs-lookup"><span data-stu-id="5f194-214">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="5f194-215">Wenn der Vorgang ausgeführt wird und erfolgreich ist, werden Ergebnis und OriginalResult auf das Ergebnis des Vorgangs festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5f194-215">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="5f194-216">Diese Werte können dann beobachtet werden, in der Interceptor-Methoden, die aufgerufen werden, nachdem der Vorgang ausgeführt wurde, d. h. auf die... Ausgeführte Methoden.</span><span class="sxs-lookup"><span data-stu-id="5f194-216">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="5f194-217">Ebenso, wenn der Vorgang ausgelöst wird, werden klicken Sie dann die Ausnahme und OriginalException Eigenschaften festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="5f194-217">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="5f194-218">Unterdrücken der Ausführung</span><span class="sxs-lookup"><span data-stu-id="5f194-218">Suppressing execution</span></span>  

<span data-ttu-id="5f194-219">Ein Interceptor die Result-Eigenschaft festgelegt, bevor der Befehl ausgeführt hat (eines der... Ausführen von Methoden) klicken Sie dann EF versucht nicht, um den Befehl tatsächlich auszuführen, aber das Resultset wird stattdessen nur verwenden.</span><span class="sxs-lookup"><span data-stu-id="5f194-219">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="5f194-220">Das heißt, kann der Interceptor unterdrücken Ausführung des Befehls, aber das vorhandenem EF fortgesetzt, als wäre, wenn der Befehl ausgeführt wurde, hatte.</span><span class="sxs-lookup"><span data-stu-id="5f194-220">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="5f194-221">Verdeutlicht, wie diese verwendet werden kann, ist, dass der Befehl, Batchverarbeitung, die normalerweise mit einem Wrapper-Anbieter erfolgt ist.</span><span class="sxs-lookup"><span data-stu-id="5f194-221">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="5f194-222">Der Interceptor als Batch den Befehl für die spätere Ausführung speichern, aber es würde "nehmen" mit EF, der der Befehl wie gewohnt ausgeführt worden.</span><span class="sxs-lookup"><span data-stu-id="5f194-222">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="5f194-223">Beachten Sie, dass sie mehr zum Implementieren der Batchverarbeitung erfordert, aber dies ist ein Beispiel, wie die Änderung des Ergebnis der Abfangfunktion verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="5f194-223">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="5f194-224">Ausführung kann auch durch Festlegen der Exception-Eigenschaft in einem der unterdrückt werden die... Ausführen von Methoden.</span><span class="sxs-lookup"><span data-stu-id="5f194-224">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="5f194-225">Dies bewirkt, dass EF fortgesetzt, als wäre die Ausführung des Vorgangs Fehler hatte, durch die angegebene Ausnahme auslösen.</span><span class="sxs-lookup"><span data-stu-id="5f194-225">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="5f194-226">Kann dies natürlich, dazu führen, dass die Anwendung zum Absturz bringen, aber es kann auch sein, eine vorübergehende Ausnahme oder sonstige Ausnahmen, die von EF behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="5f194-226">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="5f194-227">Beispielsweise könnte dies in testumgebungen verwendet werden, testen das Verhalten einer Anwendung aus, wenn es sich bei Ausführung des Befehls ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="5f194-227">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="5f194-228">Ändern das Ergebnis nach der Ausführung</span><span class="sxs-lookup"><span data-stu-id="5f194-228">Changing the result after execution</span></span>  

<span data-ttu-id="5f194-229">Wenn ein Interceptor die Result-Eigenschaft festlegt, nachdem der Befehl ausgeführt hat (eines der... Ausgeführt von Methoden) und dann EF das geänderte Ergebnis das Ergebnis verwendet wird, die tatsächlich vom Vorgang zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="5f194-229">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="5f194-230">Auf ähnliche Weise, wenn ein Interceptor die Exception-Eigenschaft festlegt, nachdem der Befehl ausgeführt wurde, EF die Set-Ausnahme löst, als ob der Vorgang die Ausnahme ausgelöst haben.</span><span class="sxs-lookup"><span data-stu-id="5f194-230">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="5f194-231">Ein Interceptor kann auch die Exception-Eigenschaft festlegen, auf null, um anzugeben, dass keine Ausnahme ausgelöst werden soll.</span><span class="sxs-lookup"><span data-stu-id="5f194-231">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="5f194-232">Dies kann nützlich sein, wenn Fehler bei der Ausführung des Vorgangs, aber der Interceptor wünscht, dass EF fortgesetzt, als wäre der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="5f194-232">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="5f194-233">Dies umfasst in der Regel auch das Ergebnis festlegen, sodass EF einige Ergebniswert hat mit arbeiten, da er weiterhin.</span><span class="sxs-lookup"><span data-stu-id="5f194-233">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="5f194-234">OriginalResult und OriginalException</span><span class="sxs-lookup"><span data-stu-id="5f194-234">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="5f194-235">Nachdem EF einen Vorgang ausgeführt wurde wird es entweder das Ergebnis und OriginalResult-Eigenschaften, wenn die Ausführung nicht fehlgeschlagen ist oder die Ausnahme und OriginalException Eigenschaften festgelegt, wenn Fehler bei der Ausführung mit einer Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="5f194-235">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="5f194-236">Die OriginalResult und OriginalException-Eigenschaften sind schreibgeschützt und nur von EF nach dem tatsächlich Ausführen eines Vorgangs festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5f194-236">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="5f194-237">Diese Eigenschaften können nicht von Interceptors festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="5f194-237">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="5f194-238">Dies bedeutet, dass alle Interceptor unterscheiden kann eine Ausnahme oder ein Ergebnis, das festgelegt wurde, indem einige andere Interceptor im Gegensatz zu der echte Ausnahme oder ein Ergebnis, die aufgetreten sind, wenn der Vorgang ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="5f194-238">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="5f194-239">Registrieren des interceptors</span><span class="sxs-lookup"><span data-stu-id="5f194-239">Registering interceptors</span></span>  

<span data-ttu-id="5f194-240">Nach der Erstellung einer Klasse, die eine oder mehrere der Abfangfunktion Schnittstellen implementiert, können sie mit EF unter Verwendung der DbInterception-Klasse registriert werden.</span><span class="sxs-lookup"><span data-stu-id="5f194-240">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="5f194-241">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="5f194-241">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="5f194-242">Interceptors können auch auf app-Domäne mithilfe der Mechanismen zur "dbconfiguration" codebasierte Konfiguration registriert werden.</span><span class="sxs-lookup"><span data-stu-id="5f194-242">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="5f194-243">Beispiel: Protokollierung NLog</span><span class="sxs-lookup"><span data-stu-id="5f194-243">Example: Logging to NLog</span></span>  

<span data-ttu-id="5f194-244">Können wir all dies zusammen in einem Beispiel, dass die Verwendung IDbCommandInterceptor und [NLog](http://nlog-project.org/) auf:</span><span class="sxs-lookup"><span data-stu-id="5f194-244">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](http://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="5f194-245">Melden Sie sich eine Warnung für solche Befehle, die nicht asynchron ausgeführt wird</span><span class="sxs-lookup"><span data-stu-id="5f194-245">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="5f194-246">Melden Sie Fehler für jeden Befehl, der auslöst, wenn ausgeführt</span><span class="sxs-lookup"><span data-stu-id="5f194-246">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="5f194-247">Dies ist die Klasse, die die Protokollierung, die registriert werden soll, wie oben gezeigt:</span><span class="sxs-lookup"><span data-stu-id="5f194-247">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="5f194-248">Beachten Sie, wie dieser Code abfangen Kontext ermitteln, wenn ein Befehl nicht asynchron ausgeführt wird und erkannt wird, wenn Fehler bei der Ausführung eines Befehls verwendet.</span><span class="sxs-lookup"><span data-stu-id="5f194-248">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
