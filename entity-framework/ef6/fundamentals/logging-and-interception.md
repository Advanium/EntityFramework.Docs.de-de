---
title: Protokollieren und Abfangen von Daten Bank Vorgängen EF6
author: divega
ms.date: 10/23/2016
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
ms.openlocfilehash: be32ed114269543ac36b256a202e0494d466e4f7
ms.sourcegitcommit: c9c3e00c2d445b784423469838adc071a946e7c9
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/18/2019
ms.locfileid: "68306530"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="11271-102">Protokollieren und Abfangen von Daten Bank Vorgängen</span><span class="sxs-lookup"><span data-stu-id="11271-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="11271-103">**Nur EF6 und höher:** Die Features, APIs usw., die auf dieser Seite erläutert werden, wurden in Entity Framework 6 eingeführt.</span><span class="sxs-lookup"><span data-stu-id="11271-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="11271-104">Wenn Sie eine frühere Version verwenden, gelten manche Informationen nicht.</span><span class="sxs-lookup"><span data-stu-id="11271-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="11271-105">Ab Entity Framework 6, wenn Entity Framework einen Befehl an die Datenbank sendet, kann dieser Befehl von Anwendungscode abgefangen werden.</span><span class="sxs-lookup"><span data-stu-id="11271-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="11271-106">Dies wird am häufigsten für die Protokollierung von SQL verwendet, kann aber auch verwendet werden, um den Befehl zu ändern oder abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="11271-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="11271-107">EF umfasst insbesondere Folgendes:</span><span class="sxs-lookup"><span data-stu-id="11271-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="11271-108">Eine Log-Eigenschaft für den Kontext, die dem DataContext. Log in ähnelt LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="11271-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="11271-109">Ein Mechanismus, mit dem der Inhalt und die Formatierung der an das Protokoll gesendeten Ausgabe angepasst werden.</span><span class="sxs-lookup"><span data-stu-id="11271-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="11271-110">Bausteine auf niedriger Ebene für die Abfang Funktion mit größerer Kontrolle und Flexibilität</span><span class="sxs-lookup"><span data-stu-id="11271-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="11271-111">Kontext Protokoll (Eigenschaft)</span><span class="sxs-lookup"><span data-stu-id="11271-111">Context Log property</span></span>  

<span data-ttu-id="11271-112">Die dbcontext. Database. Log-Eigenschaft kann auf einen Delegaten für jede Methode festgelegt werden, die eine Zeichenfolge annimmt.</span><span class="sxs-lookup"><span data-stu-id="11271-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="11271-113">In der Regel wird es mit jedem TextWriter verwendet, indem es auf die "Write"-Methode dieses Textwriters festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="11271-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="11271-114">Alle vom aktuellen Kontext generierten SQL-Informationen werden in diesem Writer protokolliert.</span><span class="sxs-lookup"><span data-stu-id="11271-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="11271-115">Mit dem folgenden Code wird z. b. SQL in der Konsole protokolliert:</span><span class="sxs-lookup"><span data-stu-id="11271-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="11271-116">Beachten Sie den Kontext. Database. log ist auf Console. Write festgelegt.</span><span class="sxs-lookup"><span data-stu-id="11271-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="11271-117">Das ist alles, was zum Protokollieren von SQL an der Konsole erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="11271-117">This is all that is needed to log SQL to the console.</span></span>  

<span data-ttu-id="11271-118">Fügen wir nun einen einfachen Abfrage-/Einfüge-/Update-Code hinzu, damit wir einige Ausgaben sehen können:</span><span class="sxs-lookup"><span data-stu-id="11271-118">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="11271-119">Dadurch wird die folgende Ausgabe generiert:</span><span class="sxs-lookup"><span data-stu-id="11271-119">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="11271-120">(Beachten Sie, dass dies die Ausgabe ist, vorausgesetzt, dass bereits eine Daten Bank Initialisierung erfolgt ist.</span><span class="sxs-lookup"><span data-stu-id="11271-120">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="11271-121">Wenn die Daten Bank Initialisierung nicht bereits erfolgt ist, gibt es eine Menge mehr Ausgabe, in der alle Arbeits Migrationen unter den Deckeln angezeigt werden, um eine neue Datenbank zu suchen oder eine neue Datenbank zu erstellen.)</span><span class="sxs-lookup"><span data-stu-id="11271-121">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

## <a name="what-gets-logged"></a><span data-ttu-id="11271-122">Was wird protokolliert?</span><span class="sxs-lookup"><span data-stu-id="11271-122">What gets logged?</span></span>  

<span data-ttu-id="11271-123">Wenn die Log-Eigenschaft festgelegt ist, wird Folgendes protokolliert:</span><span class="sxs-lookup"><span data-stu-id="11271-123">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="11271-124">SQL für alle unterschiedlichen Arten von Befehlen.</span><span class="sxs-lookup"><span data-stu-id="11271-124">SQL for all different kinds of commands.</span></span> <span data-ttu-id="11271-125">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="11271-125">For example:</span></span>  
    - <span data-ttu-id="11271-126">Abfragen, einschließlich normaler LINQ-Abfragen, ESQL-Abfragen und unformatierte Abfragen von Methoden wie sqlQuery</span><span class="sxs-lookup"><span data-stu-id="11271-126">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="11271-127">Einfügungen, Updates und Löschungen, die im Rahmen von SaveChanges generiert werden</span><span class="sxs-lookup"><span data-stu-id="11271-127">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="11271-128">Beziehungen zum Laden von Abfragen, z. b. die von generierten Lazy Loading</span><span class="sxs-lookup"><span data-stu-id="11271-128">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="11271-129">Parameter</span><span class="sxs-lookup"><span data-stu-id="11271-129">Parameters</span></span>  
- <span data-ttu-id="11271-130">Gibt an, ob der Befehl asynchron ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="11271-130">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="11271-131">Ein Zeitstempel, der angibt, wann die Ausführung des Befehls gestartet wurde</span><span class="sxs-lookup"><span data-stu-id="11271-131">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="11271-132">Gibt an, ob der Befehl erfolgreich abgeschlossen wurde oder ob ein Fehler aufgetreten ist, oder ob für Async abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="11271-132">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="11271-133">Ein Hinweis auf den Ergebniswert.</span><span class="sxs-lookup"><span data-stu-id="11271-133">Some indication of the result value</span></span>  
- <span data-ttu-id="11271-134">Der ungefähre Zeitaufwand für die Ausführung des Befehls.</span><span class="sxs-lookup"><span data-stu-id="11271-134">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="11271-135">Beachten Sie, dass dies der Zeitpunkt ist, an dem der Befehl gesendet wird, um das Ergebnis Objekt zurückzubekommen.</span><span class="sxs-lookup"><span data-stu-id="11271-135">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="11271-136">Es enthält keine Zeit zum Lesen der Ergebnisse.</span><span class="sxs-lookup"><span data-stu-id="11271-136">It does not include time to read the results.</span></span>  

<span data-ttu-id="11271-137">Wenn Sie sich die obige Beispielausgabe ansehen, werden alle vier Befehle protokolliert:</span><span class="sxs-lookup"><span data-stu-id="11271-137">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="11271-138">Die Abfrage, die sich aus dem Kontext Kontext ergibt. Blogs. First</span><span class="sxs-lookup"><span data-stu-id="11271-138">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="11271-139">Beachten Sie, dass die Methode zum Abrufen der SQL-Methode für diese Abfrage nicht funktioniert hat, da "First" keine iquerable-Methode bereitstellt, für die "destring" aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="11271-139">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="11271-140">Die Abfrage, die sich aus dem verzögerten Laden des Blogs ergibt. Beiträge</span><span class="sxs-lookup"><span data-stu-id="11271-140">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="11271-141">Beachten Sie die Parameter Details für den Schlüsselwert, für den Lazy Loading auftritt.</span><span class="sxs-lookup"><span data-stu-id="11271-141">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="11271-142">Nur Eigenschaften des-Parameters, die auf nicht standardmäßige Werte festgelegt sind, werden protokolliert.</span><span class="sxs-lookup"><span data-stu-id="11271-142">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="11271-143">Die Size-Eigenschaft wird z. b. nur angezeigt, wenn Sie ungleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="11271-143">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="11271-144">Zwei von savechangesasync resultierende Befehle eine für das Update zum Ändern eines Beitrags Titels, der andere für eine Einfügung zum Hinzufügen eines neuen Beitrags.</span><span class="sxs-lookup"><span data-stu-id="11271-144">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="11271-145">Beachten Sie die Parameter Details der Eigenschaften "FK" und "Title".</span><span class="sxs-lookup"><span data-stu-id="11271-145">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="11271-146">Beachten Sie, dass diese Befehle asynchron ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="11271-146">Notice that these commands are being executed asynchronously</span></span>  

## <a name="logging-to-different-places"></a><span data-ttu-id="11271-147">Protokollierung an verschiedenen Stellen</span><span class="sxs-lookup"><span data-stu-id="11271-147">Logging to different places</span></span>  

<span data-ttu-id="11271-148">Wie oben gezeigt, ist die Protokollierung auf der Konsole sehr einfach.</span><span class="sxs-lookup"><span data-stu-id="11271-148">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="11271-149">Es ist auch einfach, sich mit verschiedenen Arten von [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx)in Arbeitsspeicher, Datei usw. zu protokollieren.</span><span class="sxs-lookup"><span data-stu-id="11271-149">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="11271-150">Wenn Sie mit LINQ to SQL vertraut sind, können Sie feststellen, dass in LINQ to SQL die Log-Eigenschaft auf das eigentliche TextWriter-Objekt festgelegt ist (z. b. Console. out), während in EF die Log-Eigenschaft auf eine Methode festgelegt ist, die eine Zeichenfolge akzeptiert (z. b , Console. Write oder Console. out. Write).</span><span class="sxs-lookup"><span data-stu-id="11271-150">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="11271-151">Der Grund hierfür ist, EF von TextWriter zu entkoppeln, indem ein beliebiger Delegat akzeptiert wird, der als Senke für Zeichen folgen fungieren kann.</span><span class="sxs-lookup"><span data-stu-id="11271-151">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="11271-152">Stellen Sie sich beispielsweise vor, dass Sie bereits über ein Protokollierungs Framework verfügen und eine Protokollierungs Methode wie folgt definiert:</span><span class="sxs-lookup"><span data-stu-id="11271-152">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="11271-153">Dies könnte wie folgt mit der EF-Protokoll Eigenschaft verknüpft werden:</span><span class="sxs-lookup"><span data-stu-id="11271-153">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

## <a name="result-logging"></a><span data-ttu-id="11271-154">Ergebnis Protokollierung</span><span class="sxs-lookup"><span data-stu-id="11271-154">Result logging</span></span>  

<span data-ttu-id="11271-155">Die Standard Protokollierung protokolliert Befehls Text (SQL), Parameter und die Zeile "wird ausgeführt" mit einem Zeitstempel, bevor der Befehl an die Datenbank gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="11271-155">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="11271-156">Eine "Abgeschlossene" Zeile, die die verstrichene Zeit enthält, wird nach der Ausführung des Befehls protokolliert.</span><span class="sxs-lookup"><span data-stu-id="11271-156">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="11271-157">Beachten Sie, dass bei Async-Befehlen die Zeile "abgeschlossen" nicht protokolliert wird, bis die asynchrone Aufgabe tatsächlich abgeschlossen ist, fehlschlägt oder abgebrochen wird.</span><span class="sxs-lookup"><span data-stu-id="11271-157">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="11271-158">Die Zeile "abgeschlossen" enthält unterschiedliche Informationen, je nach Typ des Befehls und ob die Ausführung erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="11271-158">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

### <a name="successful-execution"></a><span data-ttu-id="11271-159">Erfolgreiche Ausführung</span><span class="sxs-lookup"><span data-stu-id="11271-159">Successful execution</span></span>  

<span data-ttu-id="11271-160">Für Befehle, die erfolgreich abgeschlossen werden, lautet die Ausgabe "abgeschlossen in x MS mit Ergebnis:", gefolgt von einem Hinweis auf das Ergebnis.</span><span class="sxs-lookup"><span data-stu-id="11271-160">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="11271-161">Für Befehle, die einen Daten Reader zurückgeben, ist die Ergebnisanzeige der Typ von [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) , der zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="11271-161">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="11271-162">Für Befehle, die einen ganzzahligen Wert zurückgeben, z. b. der oben angezeigte Befehl Update, ist die ganze Zahl.</span><span class="sxs-lookup"><span data-stu-id="11271-162">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

### <a name="failed-execution"></a><span data-ttu-id="11271-163">Fehlgeschlagene Ausführung</span><span class="sxs-lookup"><span data-stu-id="11271-163">Failed execution</span></span>  

<span data-ttu-id="11271-164">Für Befehle, die fehlschlagen, indem eine Ausnahme ausgelöst wird, enthält die Ausgabe die Meldung aus der Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="11271-164">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="11271-165">Wenn Sie z. b. sqlQuery zum Abfragen einer Tabelle verwenden, die bereits vorhanden ist, führt dies zu einer Protokoll Ausgabe wie der folgenden:</span><span class="sxs-lookup"><span data-stu-id="11271-165">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

### <a name="canceled-execution"></a><span data-ttu-id="11271-166">Ausführung abgebrochen</span><span class="sxs-lookup"><span data-stu-id="11271-166">Canceled execution</span></span>  

<span data-ttu-id="11271-167">Für asynchrone Befehle, bei denen der Task abgebrochen wird, könnte das Ergebnis ein Fehler mit einer Ausnahme sein, da dies der zugrunde liegende ADO.NET-Anbieter häufig tut, wenn versucht wird, abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="11271-167">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="11271-168">Wenn dies nicht der Fall ist und die Aufgabe ordnungsgemäß abgebrochen wird, sieht die Ausgabe in etwa wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="11271-168">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```  
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="11271-169">Ändern von Protokoll Inhalt und Formatierung</span><span class="sxs-lookup"><span data-stu-id="11271-169">Changing log content and formatting</span></span>  

<span data-ttu-id="11271-170">Unter der deckt die Database. Log-Eigenschaft ein databaselogformatter-Objekt.</span><span class="sxs-lookup"><span data-stu-id="11271-170">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="11271-171">Dieses Objekt bindet eine idbcommandinterceptor-Implementierung (siehe unten) effektiv an einen Delegaten, der Zeichen folgen und einen dbcontext akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="11271-171">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="11271-172">Dies bedeutet, dass Methoden für databaselogformatter vor und nach der Ausführung von Befehlen von EF aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="11271-172">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="11271-173">Diese databaselogformatter-Methoden erfassen und formatieren die Protokoll Ausgabe und senden Sie an den-Delegaten.</span><span class="sxs-lookup"><span data-stu-id="11271-173">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="11271-174">Anpassen von databaselogformatter</span><span class="sxs-lookup"><span data-stu-id="11271-174">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="11271-175">Änderungen, die protokolliert und formatiert werden, können erreicht werden, indem Sie eine neue Klasse erstellen, die von databaselogformatter abgeleitet ist, und die Methoden nach Bedarf überschreibt.</span><span class="sxs-lookup"><span data-stu-id="11271-175">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="11271-176">Die gängigsten Methoden zum Überschreiben lauten:</span><span class="sxs-lookup"><span data-stu-id="11271-176">The most common methods to override are:</span></span>  

- <span data-ttu-id="11271-177">Logcommand – überschreiben Sie diese Einstellung, um zu ändern, wie Befehle protokolliert werden, bevor Sie ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="11271-177">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="11271-178">Standardmäßig ruft logcommand logparameter für jeden Parameter auf. Sie können in Ihrem Außerkraftsetzungs Vorgang dasselbe tun oder Parameter unterschiedlich behandeln.</span><span class="sxs-lookup"><span data-stu-id="11271-178">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="11271-179">Logresult – überschreiben Sie diese, um zu ändern, wie das Ergebnis der Ausführung eines Befehls protokolliert wird.</span><span class="sxs-lookup"><span data-stu-id="11271-179">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="11271-180">Logparameter – überschreiben Sie diese Einstellung, um die Formatierung und den Inhalt der Parameter Protokollierung zu ändern.</span><span class="sxs-lookup"><span data-stu-id="11271-180">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="11271-181">Angenommen, es soll nur eine einzelne Zeile protokolliert werden, bevor jeder Befehl an die Datenbank gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="11271-181">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="11271-182">Dies kann mit zwei über schreibungen erfolgen:</span><span class="sxs-lookup"><span data-stu-id="11271-182">This can be done with two overrides:</span></span>  

- <span data-ttu-id="11271-183">Überschreiben von logcommand zum Formatieren und Schreiben der einzelnen Zeile von SQL</span><span class="sxs-lookup"><span data-stu-id="11271-183">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="11271-184">Überschreiben Sie logresult, um nichts zu tun.</span><span class="sxs-lookup"><span data-stu-id="11271-184">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="11271-185">Der Code sieht in etwa wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="11271-185">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="11271-186">Zum Protokollieren der Ausgabe können Sie einfach die Write-Methode abrufen, die die Ausgabe an den konfigurierten Schreib Delegaten sendet</span><span class="sxs-lookup"><span data-stu-id="11271-186">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="11271-187">(Beachten Sie, dass dieser Code eine vereinfachte Entfernung von Zeilenumbrüchen als Beispiel bewirkt.</span><span class="sxs-lookup"><span data-stu-id="11271-187">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="11271-188">Dies funktioniert wahrscheinlich nicht gut für die Anzeige von komplexem SQL.)</span><span class="sxs-lookup"><span data-stu-id="11271-188">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="11271-189">Festlegen von databaselogformatter</span><span class="sxs-lookup"><span data-stu-id="11271-189">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="11271-190">Nachdem eine neue databaselogformatter-Klasse erstellt wurde, muss Sie bei EF registriert werden.</span><span class="sxs-lookup"><span data-stu-id="11271-190">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="11271-191">Dies erfolgt mithilfe der Code basierten Konfiguration.</span><span class="sxs-lookup"><span data-stu-id="11271-191">This is done using code-based configuration.</span></span> <span data-ttu-id="11271-192">Kurz gesagt bedeutet dies, dass Sie eine neue Klasse erstellen, die von dbconfiguration in derselben Assembly wie die dbcontext-Klasse abgeleitet ist, und dann setdatabaselogformatter im Konstruktor dieser neuen Klasse aufrufen.</span><span class="sxs-lookup"><span data-stu-id="11271-192">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="11271-193">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="11271-193">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="11271-194">Verwenden des neuen databaselogformatter-Objekts</span><span class="sxs-lookup"><span data-stu-id="11271-194">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="11271-195">Dieser neue databaselogformatter wird jetzt verwendet, wenn "Database. log" festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="11271-195">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="11271-196">Wenn Sie den Code aus Teil 1 ausführen, führt dies nun zur folgenden Ausgabe:</span><span class="sxs-lookup"><span data-stu-id="11271-196">So, running the code from part 1 will now result in the following output:</span></span>  

```  
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="11271-197">Abfang Bausteine</span><span class="sxs-lookup"><span data-stu-id="11271-197">Interception building blocks</span></span>  

<span data-ttu-id="11271-198">Bisher haben wir uns mit der Verwendung von "dbcontext. Database. log" zum Protokollieren des von EF generierten SQL beschäftigt.</span><span class="sxs-lookup"><span data-stu-id="11271-198">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="11271-199">Dieser Code ist jedoch eine relativ schlanke Fassade über einigen gering stufigen Bausteinen für eine allgemeinere Abfang Funktion.</span><span class="sxs-lookup"><span data-stu-id="11271-199">But this code is actually a relatively thin facade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="11271-200">Abfang Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="11271-200">Interception interfaces</span></span>  

<span data-ttu-id="11271-201">Der Abfang Code basiert auf dem Konzept der Abfang Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="11271-201">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="11271-202">Diese Schnittstellen erben von idbinterceptor und definieren Methoden, die aufgerufen werden, wenn EF einige Aktionen ausführt.</span><span class="sxs-lookup"><span data-stu-id="11271-202">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="11271-203">Die Absicht besteht darin, dass eine Schnittstelle pro Objekttyp abgefangen wird.</span><span class="sxs-lookup"><span data-stu-id="11271-203">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="11271-204">Die idbcommandinterceptor-Schnittstelle definiert z. b. Methoden, die aufgerufen werden, bevor EF einen Aufruf an ExecuteNonQuery, ExecuteScalar, ExecuteReader und verwandte Methoden sendet.</span><span class="sxs-lookup"><span data-stu-id="11271-204">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="11271-205">Ebenso definiert die-Schnittstelle Methoden, die aufgerufen werden, wenn jeder dieser Vorgänge abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="11271-205">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="11271-206">Die zuvor betrachtete databaselogformatter-Klasse implementiert diese Schnittstelle zum Protokollieren von Befehlen.</span><span class="sxs-lookup"><span data-stu-id="11271-206">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="11271-207">Der Abfang Kontext</span><span class="sxs-lookup"><span data-stu-id="11271-207">The interception context</span></span>  

<span data-ttu-id="11271-208">Wenn Sie die Methoden betrachten, die für eine der Interceptor Schnittstellen definiert sind, ist es offensichtlich, dass jedem-Befehl ein Objekt vom Typ "dbinterceptioncontext" oder ein von diesem abgeleiteter Typ, wie z. b. dbcommandinterceptioncontext\<\></span><span class="sxs-lookup"><span data-stu-id="11271-208">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="11271-209">Dieses Objekt enthält Kontextinformationen zu der Aktion, die EF durch nimmt.</span><span class="sxs-lookup"><span data-stu-id="11271-209">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="11271-210">Wenn die Aktion z. b. im Namen eines dbcontext ausgeführt wird, ist dbcontext im dbinterceptioncontext enthalten.</span><span class="sxs-lookup"><span data-stu-id="11271-210">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="11271-211">Analog dazu wird für Befehle, die asynchron ausgeführt werden, das IsAsync-Flag für dbcommandinterceptioncontext festgelegt.</span><span class="sxs-lookup"><span data-stu-id="11271-211">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="11271-212">Ergebnis Behandlung</span><span class="sxs-lookup"><span data-stu-id="11271-212">Result handling</span></span>  

<span data-ttu-id="11271-213">Die dbcommandinterceptioncontext\< \> -Klasse enthält die Eigenschaften "result", "originalresult", "Exception" und "originalexception".</span><span class="sxs-lookup"><span data-stu-id="11271-213">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="11271-214">Diese Eigenschaften werden für Aufrufe der Abfang Methoden, die vor der Ausführung des Vorgangs aufgerufen werden, auf Null/0 (null) festgelegt – d. h. für die... Ausführen von Methoden.</span><span class="sxs-lookup"><span data-stu-id="11271-214">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="11271-215">Wenn der Vorgang ausgeführt wird und erfolgreich ist, werden result und originalresult auf das Ergebnis des Vorgangs festgelegt.</span><span class="sxs-lookup"><span data-stu-id="11271-215">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="11271-216">Diese Werte können dann in den Abfang Methoden beobachtet werden, die nach der Ausführung des Vorgangs aufgerufen werden – d. h. auf dem... Ausgeführte Methoden.</span><span class="sxs-lookup"><span data-stu-id="11271-216">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="11271-217">Ebenso werden, wenn der Vorgang ausgelöst wird, die Eigenschaften Exception und originalexception festgelegt.</span><span class="sxs-lookup"><span data-stu-id="11271-217">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="11271-218">Unterdrücken der Ausführung</span><span class="sxs-lookup"><span data-stu-id="11271-218">Suppressing execution</span></span>  

<span data-ttu-id="11271-219">Wenn ein Interceptor die Ergebnis Eigenschaft festlegt, bevor der Befehl ausgeführt wurde (in einer der... Ausführen von Methoden) dann versucht EF nicht, den Befehl tatsächlich auszuführen, sondern verwendet stattdessen nur das Resultset.</span><span class="sxs-lookup"><span data-stu-id="11271-219">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="11271-220">Mit anderen Worten: der Interceptor kann die Ausführung des Befehls unterdrücken, aber EF kann fortgesetzt werden, als ob der Befehl ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="11271-220">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="11271-221">Ein Beispiel dafür, wie dies verwendet werden kann, ist die Batch Verarbeitung des Befehls, die bisher mit einem Wrapping Anbieter durchgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="11271-221">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="11271-222">Der-Interceptor speichert den Befehl für die spätere Ausführung als Batch, aber würde den Befehl "vorgeben", um EF darauf zu warten, dass der Befehl wie gewohnt ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="11271-222">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="11271-223">Beachten Sie, dass es mehr als die Implementierung der Batch Verarbeitung erfordert, aber dies ist ein Beispiel dafür, wie die Änderung des Abfang Ergebnisses verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="11271-223">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="11271-224">Die Ausführung kann auch durch Festlegen der Exception-Eigenschaft in einer der... Ausführen von Methoden.</span><span class="sxs-lookup"><span data-stu-id="11271-224">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="11271-225">Dies bewirkt, dass EF fortgesetzt wird, als ob die Ausführung des Vorgangs fehlgeschlagen ist, indem die angegebene Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="11271-225">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="11271-226">Dies kann natürlich dazu führen, dass die Anwendung abstürzt, aber es kann auch eine vorübergehende Ausnahme oder eine andere Ausnahme sein, die von EF behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="11271-226">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="11271-227">Dies kann z. b. in Testumgebungen verwendet werden, um das Verhalten einer Anwendung zu testen, wenn die Befehlsausführung fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="11271-227">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="11271-228">Ändern des Ergebnisses nach der Ausführung</span><span class="sxs-lookup"><span data-stu-id="11271-228">Changing the result after execution</span></span>  

<span data-ttu-id="11271-229">Wenn ein Interceptor die Ergebnis Eigenschaft festlegt, nachdem der Befehl ausgeführt wurde (in einer der... Ausgeführte Methoden) dann verwendet EF das geänderte Ergebnis anstelle des Ergebnisses, das tatsächlich vom Vorgang zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="11271-229">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="11271-230">Wenn ein Interceptor die Exception-Eigenschaft nach dem Ausführen des Befehls festlegt, löst EF die festgelegte Ausnahme aus, als ob der Vorgang die Ausnahme ausgelöst hätte.</span><span class="sxs-lookup"><span data-stu-id="11271-230">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="11271-231">Ein Interceptor kann die Exception-Eigenschaft auch auf NULL festlegen, um anzugeben, dass keine Ausnahme ausgelöst werden soll.</span><span class="sxs-lookup"><span data-stu-id="11271-231">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="11271-232">Dies kann hilfreich sein, wenn die Ausführung des Vorgangs fehlgeschlagen ist, der Interceptor jedoch wünscht, dass EF fortgesetzt wird, als ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="11271-232">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="11271-233">Dies umfasst in der Regel auch das Festlegen des Ergebnisses, damit EF mit einem Ergebniswert arbeiten kann, wenn er fortgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="11271-233">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="11271-234">Originalresult und originalexception</span><span class="sxs-lookup"><span data-stu-id="11271-234">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="11271-235">Nachdem EF einen Vorgang ausgeführt hat, werden die Eigenschaften result und originalresult festgelegt, wenn die Ausführung nicht erfolgreich war, oder die Eigenschaften Exception und originalexception, wenn die Ausführung mit einer Ausnahme fehlgeschlagen ist.</span><span class="sxs-lookup"><span data-stu-id="11271-235">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="11271-236">Die Eigenschaften originalresult und originalexception sind schreibgeschützt und werden nur von EF festgelegt, nachdem ein Vorgang tatsächlich ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="11271-236">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="11271-237">Diese Eigenschaften können nicht durch Interceptors festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="11271-237">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="11271-238">Dies bedeutet, dass jeder Interceptor zwischen einer Ausnahme oder einem Ergebnis unterscheiden kann, die von einem anderen Interceptor festgelegt wurde. Dies gilt nicht für die tatsächliche Ausnahme oder das Ergebnis, das beim Ausführen des Vorgangs aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="11271-238">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="11271-239">Interceptors werden registriert</span><span class="sxs-lookup"><span data-stu-id="11271-239">Registering interceptors</span></span>  

<span data-ttu-id="11271-240">Sobald eine Klasse, die eine oder mehrere der Abfang Schnittstellen implementiert, erstellt wurde, kann Sie mithilfe der dbintercep-Klasse bei EF registriert werden.</span><span class="sxs-lookup"><span data-stu-id="11271-240">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="11271-241">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="11271-241">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="11271-242">Interceptors können auch auf der Ebene der APP-Domäne mithilfe des Code basierten Konfigurations Mechanismus von dbconfiguration registriert werden.</span><span class="sxs-lookup"><span data-stu-id="11271-242">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="11271-243">Beispiel: Protokollierung in nlog</span><span class="sxs-lookup"><span data-stu-id="11271-243">Example: Logging to NLog</span></span>  

<span data-ttu-id="11271-244">Fügen wir das alles in ein Beispiel ein, das idbcommandinterceptor und [nlog](http://nlog-project.org/) für Folgendes verwendet:</span><span class="sxs-lookup"><span data-stu-id="11271-244">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](http://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="11271-245">Protokolliert eine Warnung für jeden Befehl, der nicht asynchron ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="11271-245">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="11271-246">Protokolliert einen Fehler für jeden Befehl, der beim Ausführen auslöst.</span><span class="sxs-lookup"><span data-stu-id="11271-246">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="11271-247">Hier ist die Klasse, die die Protokollierung durchführt, die wie oben beschrieben registriert werden sollte:</span><span class="sxs-lookup"><span data-stu-id="11271-247">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="11271-248">Beachten Sie, dass dieser Code den Abfang Kontext verwendet, um zu ermitteln, wann ein Befehl nicht asynchron ausgeführt wird, und um herauszufinden, wann beim Ausführen eines Befehls ein Fehler aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="11271-248">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
